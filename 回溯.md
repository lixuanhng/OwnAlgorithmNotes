### 回溯算法相关

观点：深度优先遍历，递归，栈三者的关系，背后的统一逻辑都是【后进先出】

1. 回溯法：
   + 采用试错的思想，分步解决一个问题
   + 当现有分布答案不能解决问题时，则取消上一步甚至上几步的计算，再通过其他的，可能的分步解答尝试其他答案
   + 常使用递归
   + 重复计算的结果是：
     + 找到一个可能存在的答案
     + 尝试所有组合或可能后发现没有答案

2. 深度优先搜索
   + 用于便利或者搜索树（图）的算法，尽可能深的搜索树的分支
   + 当节点`v`的所在边都已经被探寻过，搜索将回溯到发现结点 `v` 的那条边的起始结点。直到访问完所有节点

3. 二者联系：
   + 【回溯算法】强调了【深度优先遍历】思想的用途，用一个 **不断变化** 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 **回退** 操作对于搜索的合理性。
   + 【深度优先遍历】强调一种遍历的思想
   + 搜索和遍历的区别：
     + 搜索问题的解，可以通过 **遍历** 实现。
     + 回溯算法用于 **搜索一个问题的所有的解** ，通过深度优先遍历的思想实现。
   + 【回溯】与【动态规划】的区别：
     + 共同点：求解多阶段决策问题
       + 求解一个问题分为很多步骤（阶段）
       + 每一个步骤（阶段）可以有多种选择
     + 不同点：
       + 【动态规划】只需要求我们评估最优解是多少，对应的具体解不要求，用于评估方案效果
       + 回溯算法可以搜索得到所有的方案（当然包括最优解），本质上是遍历，时间复杂度很高。
4. 搜索的方法：
   + 按顺序枚举每一位可能出现的情况，已经选择的数字在 **当前** 要选择的数字中不能出现。按照这种策略搜索就能够做到 **不重不漏**。
5. 逻辑：
   + 状态：变量的不同值
   + 状态重置：状态变量需要设置为和先前一样，也就是撤回上一次的选择
   + 深度优先遍历：往下走时在路径`path`变量尾部添加，撤销时在`path`变量尾部撤销，`path`变量就是栈。【深度优先遍历】通过【回溯】操作，实现了全局使用一份状态变量的效果
   + 从树的根节点到叶子结点形成的路径就是其中一个全排列
6. 设计状态变量：
   + 递归结构
   + 递归终止条件，当前程序递归到第几层
   + 布尔数组，表示哪些数还没有选择过，选择过的用True，没有选择过的用False
7. 为什么不使用广度优先遍历：
   + 深度优先遍历中每两个状态之间只相差一个位置的变化，退回比较容易；但是广度优先由浅层转到深层状态变化比较大；
   + 深度优先直接使用系统栈，而广度优先遍历则需要使用队列，存储每一步的状态信息，可能会产生很大的冗余
8. 剪枝
   + 回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；



46，全排列，中等

核心方法：回溯

难点：

1. 需要传入深度优先遍历的参数
   + 不变的参数：数组本身，数组长度
   + 变化的参数：每次的排列`path`，存储排列的结果`res`，递归到的层数`depth`，还可以选择的元素数组`used`
2. 存储结果时，需要将排列结果拷贝一份，再加入结果中；这里使用`path[:]`，因为原始列表的变量名只是提供了一个指向列表的指针，如果直接使用`res.append(path)`，那么传入的只是这个指针，会随着path变化而变化，最后的结果会是6个空列表（由于path最终会回到初始值`[]`），而不是排列。
3. 复杂度分析
   + 时间复杂度：*O*(*N*×*N*!)
   + 空间复杂度：*O*(*N*×*N*!)
     + 递归树深度 log*N*；
     + 全排列个数 *N*!，每个全排列占空间 *N*。取较大者。

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def dfs(nums, n, depth, path, used, res):
            if depth == n:
                res.append(path[:])
                return res
			# 开始遍历整个数组
            for i in range(n):
                # 如果当前遍历到的元素没有被使用，那么
                if not used[i]:
                    used[i] = True
                    path.append(nums[i])
					# 开始递归
                    dfs(nums, n, depth+1, path, used, res)
					# 开始回溯，对当前位置的值进行撤回，使用状态恢复为未使用
                    used[i] = False
                    path.pop()
                    
        def dfs1(path, depth):
            # 这个方法占用的空间比较大，耗时比较多
            # 创建很多中间变量，这些中间变量有些是不需要的
            if depth == n:
                res.append(path)
                return res
            for i in range(n):
                if not used[i]:
                    used[i] = 1
                    dfs(path + [nums[i]], depth+1)
                    used[i] = 0

        n = len(nums)
        if n == 0: return []
        
        used = [False for _ in range(n)]
        res = list()
        # 开始进行树的搜索
        dfs(nums, n, 0, [], used, res)
        return res
```



22，括号生成，中等

此题已经记录过了，可以参考之前【数组】代码

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # 哪些还没有选择过，使用L和R表示左右括号剩余可用的个数
        def dfs(cur_str, L, R):
            if L == 0 and R == 0:
                # 递归终止条件
                res.append(cur_str)
                return 
            if right < left:
                # 剪枝，代表递归结束，右括号的数量一定是大于左括号的
                return 
            if L > 0:
                # 如果左括号还有，则继续添加，右括号情况相同
                dfs(cur_str + '(', L-1, R)
            if R > 0:
                dfs(cur_str + ')', L, R-1)
        
        res = []
        dfs('', n, n)
        return res
```



剑指offer38，字符串的排列，中等

核心方法：回溯

难点：如果原始字符串中包含重复字符，需要在每层循环开始之前设置一个集合，因为每次开始新的一轮回溯，相当于是获取一个新位置的值；那么加在每层循环前的集合，就是针对这个位置进行去重的。也就是说，如果这个位置已经存在了相同的值，那么直接跳到下一个元素。这样比较有效

+ 时间复杂度：时间复杂度 $O(N!N)$ ： N 为字符串 s 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 $N \times (N-1) \times (N-2) … \times 2 \times 1$ ，即复杂度为 $O(N!)$  。

+ 空间复杂度 $O(N^2)$ ： 全排列的递归深度为 $N$ ，系统累计使用栈空间大小为 $O(N)$ ；递归中辅助 `Set` 累计存储的字符数量最多为 $N + (N-1) + ... + 2 + 1 = (N+1)N/2$ ，即占用 $O(N^2)$ 的额外空间。


```python
class Solution:
    def permutation(self, s: str) -> List[str]:
        self.res = []
        self.ans = ''
        n = len(s)

        def backtrack(s):
            if len(self.ans) == n:
                self.res.append(str(self.ans))
                return
            dic = set()  # 设立哨兵集合来阻挡重复进入
            for i in range(0,len(s)):
                if s[i] in dic: continue  # 重复则略过此次循环，称为剪枝
                dic.add(s[i])  # 记得不在的时候需要放入set
                self.ans += s[i]
                backtrack(s[:i] + s[i+1:])  # 排除掉当前的i，将s中剩余的字符串再进行回溯
                self.ans = self.ans[:-1]
        backtrack(s)
        return list(self.res)
```



10，正则表达式匹配，困难

核心方法：回溯

难点：查找`s`和`p`的每个位置是否匹配

+ 如果只有`'.'`的情况，我们需要从左到右依次判断`s[i]`和`p[i]`是否匹配
+ 如果有`'*'`，会出现在p[1]的位置
  + 如果匹配0个，那么忽略`'*'`以及前面的字符，继续比较下一个
  + 如果匹配一个或多个，那么忽略掉s中的第一个元素，继续比较下一个

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # 终止条件：如果p为空，如果s为空则为True（两个都查找完了）
        # 如果s不为空，则为False，表示不能匹配上，因为s还有剩余
        if not p: return not s
        # 第一个字母是否匹配
        # 即判断s是否有剩余，p[0]是否等于s[0]或者'.'
        first_match = bool(s and p[0] in {s[0],'.'})
        # 如果 p 第二个字母是 *
        if len(p) >= 2 and p[1] == "*":
            # self.isMatch(s, p[2:]) 表示忽略掉p中的前两个，这时可以不考虑第一个位置是否匹配，因为即使第一个位置没有匹配到，p[:2]匹配的也是0个
            # 或者 first_match 为 True
            return self.isMatch(s, p[2:]) or first_match and self.isMatch(s[1:], p)
        else:
            return first_match and self.isMatch(s[1:], p[1:])
```

核心方法：动态规划

难点：`dp[i][j]` 表示的状态是 s 的前 i 项和 p 的前 j 项是否匹配。

已知了 `dp[i-1][j-1]` 的状态，分三种情况确定 `dp[i][j]` 的状态

+ `s[i] == p[j] or p[j] == '.'`时`dp[i][j] = dp[i-1][j-1] = True`
+ `p[j] == '*'`，星号与前面的字符相关，比较星号前面的字符 `p[j-1]` 和 `s[i]` 的关系。
  + `p[j-1] != s[i]`：如果星号前一个字符匹配不上，星号匹配了 0 次。应忽略这两个字符，看 `p[j-2]` 和 `s[i]` 是否匹配。 这时 `dp[i][j] = dp[i][j-2]`。
  + `p[j-1] == s[i] or p[j-1] == '.'`：星号前面的字符可以与 `s[i]` 匹配，这种情况下，星号可能匹配了前面的字符的 0 个，也可能匹配了前面字符的多个。当匹配 0 个时，这时我们需要去掉 p 中的 `b*` 或 `.*` 后进行比较，即 `dp[i][j] = dp[i][j-2]`；当匹配多个时，我们需要将 `s[i]` 前面的与 p 重新比较，即 `dp[i][j] = dp[i-1][j]`
+ 其他情况为不匹配，即 `dp[i][j] = False`

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # 边界条件，考虑 s 或 p 分别为空的情况
        if not p: return not s
        if not s and len(p) == 1: return False
		
        
        m, n = len(s) + 1, len(p) + 1
        # 所有初始状态全部设置为 False
        dp = [[False for _ in range(n)] for _ in range(m)]
        # 初始状态
        dp[0][0] = True
        dp[0][1] = False
		
        # 当 s 为空字符串时，p字符串能否与之匹配需要分情况讨论
        # 如果s为空，p等于'a*'时，那么s与p是匹配的，此时 dp[0][2] = dp[0][0]
        # 缺少的2就是'a*'的长度
        for c in range(2, n):
            # 在这个循环中n是取不到的，当时由于n = len(p) + 1，c 可以取到p的最后一个字符
            # 实际在状态转移的过程中，如果已经确定[j]的情况了，那么之后只需要关注[j+1]的情况
            # 所以这里和后面都使用了相同的处理方法：j = c - 1 和 i = r - 1
            j = c - 1  # 判断时使用j，使用c进行状态转移
            if p[j] == '*':
                dp[0][c] = dp[0][c - 2]
        
        for r in range(1,m):
            i = r - 1
            for c in range(1, n):
                j = c - 1
                if s[i] == p[j] or p[j] == '.':
                    dp[r][c] = dp[r - 1][c - 1]
                elif p[j] == '*':       # ‘*’前面的字符匹配s[i] 或者为'.'
                    if p[j - 1] == s[i] or p[j - 1] == '.':
                        dp[r][c] = dp[r - 1][c] or dp[r][c - 2]
                    else:                       # ‘*’匹配了0次前面的字符
                        dp[r][c] = dp[r][c - 2] 
        return dp[m - 1][n - 1]
```



131，分割回文串，中等

核心方法：回溯+动态规划

+ 时间复杂度：$O(n \cdot 2^n)$，其中 n 是字符串 s 的长度。在最坏情况下，s 包含 n 个完全相同的字符，因此它的任意一种划分方法都满足要求。而长度为 n 的字符串的划分方案数为 $2^{n-1}=O(2^n)$，每一种划分方法需要 $O(n)$ 的时间求出对应的划分结果并放入答案，因此总时间复杂度为 $O(n \cdot 2^n)$。
+ 空间复杂度：数组 *f* 需要使用的空间为 $O(n^2)$

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        # 采用回溯 + 动态规划预处理
        n = len(s)
        dp = [[True] * n for _ in range(n)]
        
        # 使用动态规划首先将所有s的所有子串全部预处理出来
        for i in range(n-1, -1, -1):
            for j in range(i+1, n):
                # s[i..j]是回文串的条件：头尾字符相等，且s[i+1..j-1]是回文串
                # 或者 i >= j: 也就是同一个字符，或者是空串，所以这里的j从i+1开始
                dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]

        res = list()
        ans = list()

        # 深度优先遍历
        def dfs(i):
            # 终止条件：当起始值i等于重点值n，表示遍历完毕
            if i == n:
                res.append(ans[:])
                return 
            
            for j in range(i, n):
                if dp[i][j]:
                    ans.append(s[i:j+1])
                    dfs(j+1)  # 后面一个位置进行递归
                    ans.pop()
        dfs(0)
        return res
```



93，复原IP地址，中等

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        def isValid(s, start, end):
            """传入：字符串s，开始处理s的起始位置，字符串s末尾索引"""
            if start > end:
                # 如果已经超出去了，就返回无效
                return False
            if s[start] == '0' and start != end:
                # 如果第一位是0，而且这个IP段长度大于1，返回无效
                # start != end 表示这一个IP段的长度已经大于1了，此时的s是添加"."后的结果，
                # end表示s末尾索引，如果start表示第4个IP段的第一个字符索引
                # 如果有效，那么s[start]==0时，start = end，否则无效
                return False
            num = 0
            for i in range(start, end + 1):
                if s[i] > '9' or s[i] < '0':
                    # 字符如果大于9或者小于0，返回无效
                    return False
                num = num*10 + (int(s[i]) - 0)
                if num > 255:
                    # 转为int型后，如果超出边界，则无效
                    return False
            # 都不满足，则返回有效
            return True

        def backtracking(s, startindex, pointnum):
            """
            传入【字符串s，起始位置，"."的个数】
            """r
            if pointnum == 3:
                # 在字符串中插入了3个"."时，说明已将s划分完成，此时进行有效性判断
                if isValid(s, startindex, len(s)-1):
                    # 如果返回有效，则将结果添加到res中
                    res.append(s)
                return  # 剪枝
            for i in range(startindex, len(s)):
                # 此处i为s的所有索引
                if isValid(s, startindex, i):
                    # 这里的有效性判断，主要是为了验证已划分出来的，最右边的区间是否有效
                    # 这里相当于添加并移动了“.”的位置在整个s中
                    s = s[:i+1] + '.' + s[i+1:]
                    pointnum += 1
                    backtracking(s, i+2, pointnum)  # 这里+2是由于中间插入了一个"."
                    # 这里传入的i+2作为下一次的startindex，表示的是下一个待处理的字符
                    pointnum -= 1  # 不满足这个条件时，pointnum-1表示去掉上一个区间的划分
                    # 去掉上一个添加的"."，接下来重新进行循环，重新分配"."的位置
                    s = s[:i+1] + s[i+2:]  
                else:
                    break
        
        # 如果字符串长度大于12，则直接返回空
        if len(s) > 12:
            return []
        res = list()
        # 下面的0，表示每个IP字段（长度为3）中当前指向的位置，在0，1，2三个数当中的一个
        backtracking(s, 0, 0)
        return res
```

