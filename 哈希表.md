**739，每日温度，中等**

核心方法：维护一个数组nxt，记录每个温度第一次出现的下标，数组中的元素初始化为无穷大，在遍历过程中更新nxt的值；反向遍历数据，对于每个遍历到的元素，从nxt中找到从这个元素到100中每个温度第一次出现的下标，找到的下标减去当前的元素下标即为下一次比当天高的等待天数，最后向nxt中加入新确定的温度和对应的下标

+ 复杂度：
  + 时间复杂度：`O(mn)`，其中`n`是温度列表的长度，`m`是数组`nxt`的长度
  + 空间复杂度：`O(m)`

```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        n = len(T)
        ans, nxt, big = [0] * n, dict(), 10**9
        for i in range(n - 1, -1, -1):  # 从尾向前遍历
            warmer_index = min(nxt.get(t, big) for t in range(T[i] + 1, 102))  # 求所有大于当前温度的最小下标位置
            if warmer_index != big:
                # 如果这个下标不等于无穷大，则等待天数就是找到的温度的下标-当前温度下标
                ans[i] = warmer_index - i
            nxt[T[i]] = i  # 更新nxt表
        return ans
```

+ <font color=red>（推荐）</font>核心方法：使用单调栈，元素索引入栈，进栈规则为：1、栈为空，2、当前温度比栈顶温度低时；如果当前温度比栈顶温度高，那么栈顶元素出栈，天数就是当前温度对应索引-栈顶元素索引，直到所有小的栈顶元素全部出栈，然后将当前元素索引入栈
+ 复杂度分析
  + 时间复杂度：O(n)
  + 空间复杂度：O(n)

```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        n = len(T)
        res = [0] * n
        stack = []
        for i in range(n):
            tmp = T[i]
            while stack and T[stack[-1]] < tmp:
                idx = stack.pop()
                res[idx] = i - idx
            stack.append(i)
        return res
```



**136，只出现一次的数据，简单**

**核心方法**：使用字典记录元素出现的频率

**复杂度分析**：

+ 时间复杂度：O(n)
+ 空间复杂度：O(n)

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        freq = dict()
        for i in range(len(nums)):
            if nums[i] not in freq.keys():
                freq[nums[i]] = 1
            else:
                freq[nums[i]] += 1
        for k, v in freq.items():
            if v == 1:
                return k
```

**异或运算** （位操作）

+ 异或运算的三个性质：
  + 任何数与自己异或等于0
  + 任何数与0异或等于自己
  + 异或运算满足交换律和结合律
  + 假设共有2m+1个数，只有一个是出现一次的，那么使用异或运算(*a*1⊕*a*1)⊕(*a*2⊕*a*2)⊕⋯⊕(*a* *m*⊕*a* *m*)⊕*a* *m*+1，最后等于*a* m+1，结果就是出现一次的数

+ 时间复杂度：O(n)
+ 空间复杂度：O(1)

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, nums)
```



18，四数之和，中等

**核心方法**：排序，双指针，

**难点**：数组排序，首先使用两重循环取出数组中的前两个数，然后使用双指针遍历后面的数，如果遇到与前面相同的数，则跳过，这样可以避免出现重复四元组；还可以添加一些剪枝操作；假设前面两层循环确定的数为`i`和`j`，那么左指针为`j+1`，右指针为`length-1`。

复杂度分析：

+ 时间复杂度：O(n^3)，其中 n 是数组的长度。排序的时间复杂度是 O(nlogn)，枚举四元组的时间复杂度是 O(n^3)，因此总时间复杂度为 O(n^3 +nlogn)=O(n^3 )。
+ 空间复杂度：O(logn)，其中 n 是数组的长度。空间复杂度主要取决于排序额外使用的空间。此外排序修改了输入数组 nums，实际情况中不一定允许，因此也可以看成使用了一个额外的数组存储了数组 nums 的副本并排序，空间复杂度为 O(n)。

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        quadruplets = list()
        if not nums or len(nums) < 4:
            return quadruplets
        
        # 排序
        nums.sort()
        length = len(nums)
        for i in range(length - 3):
            # 这里设置 length-3 是为了后面还要留出3位
            if i > 0 and nums[i] == nums[i - 1]:
                # 和前一个一样，就跳过
                continue
            if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target:
                # 剪枝，如果挨着的四数之和已经大于target，后面如何遍历都不会等于target，退出循环
                break
            if nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target:
                # 剪枝，第一位和后三位的和已经小于target，遍历中间也不会等于target，跳过
                continue
            for j in range(i + 1, length - 2):
                # 和上一重循环内容相同，处理方式相同
                if j > i + 1 and nums[j] == nums[j - 1]:
                    continue
                if nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target:
                    break
                if nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target:
                    continue
                left, right = j + 1, length - 1
                while left < right:
                    total = nums[i] + nums[j] + nums[left] + nums[right]
                    if total == target:
                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])
                        while left < right and nums[left] == nums[left + 1]:
                            # 注意需要保证移动后，左指针要小于右指针
                            # 和移动方向的下一个一样，就跳过
                            left += 1
                        left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            # 和移动方向的下一个一样，就跳过
                            right -= 1
                        right -= 1
                    elif total < target:
                        left += 1
                    else:
                        right -= 1
        
        return quadruplets
```



49，字符异位词分组，中等

核心方法：对每个字符串进行排序，作为分组的标志字符串（键），将每组的结果添加到这个键对应的列表值中

时间复杂度：O(nklogk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。

空间复杂度：O(nk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的最大长度。需要用哈希表存储全部字符串。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        mp = collections.defaultdict(list)
        for s in strs:
            key = ''.join(sorted(s))
            mp[key].append(key)
        return list(mp.values())
```

核心方法：由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。

时间复杂度：O(n(k+∣Σ∣))，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣=26。 

空间复杂度：O(n(k+∣Σ∣))，记录每个字符串内每个字母出现次数需要Σ，且元组中需要k个位置作为键

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        mp = collections.defaultdict(list)

        for st in strs:
            counts = [0] * 26  # 使用固定大小的数组来记录每个字符串出现的次数
            for ch in st:
                counts[ord(ch) - ord("a")] += 1
            # 需要将 list 转换成 tuple 才能进行哈希
            mp[tuple(counts)].append(st)
        
        return list(mp.values())
```



347，前K个高频元素，中等

核心方法：首先对nums做元素-频率字典，然后对字典的value进行降序排序，然后取出前k个

时间复杂度：排序的时间复杂度为O(nlogn)

空间复杂度：新建了一个字典，字典长度最大为n，所以O(n)

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        freq = dict()
        for n in nums:
            if n not in freq.keys():
                freq[n] = 1
            else:
                freq[n] += 1
        freq_ = sorted(list(freq.items()), key=lambda x:x[1], reverse=True)
        res = []
        for i in range(k):
            res.append(freq_[i][0])
        return res
```



349，两个数组的交集，简单

核心方法：使用set集合来做

时间复杂度：O(m+n)，m和n分别为两个数组的长度，使用两个集合分别存储两个数组中的元素需要 O(m+n) 的时间

空间复杂度：O(m+n)，空间复杂度主要取决于两个集合。

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set1 = set(nums1)
        set2 = set(nums2)
        return self.set_intersection(set1, set2)

    def set_intersection(self, set1, set2):
        if len(set1) > len(set2):
            return self.set_intersection(set2, set1)
        return [x for x in set1 if x in set2]
```

核心方法：排序+双指针

难点：两个指针遍历两个数组，起始分别指向两个数组的头部，每次比较两个指针的两个数组中的数字，如果不相等，移动较小值的那个指针，如果相等，则需要判断这个值是否等于上一个加入结果列表中的值，不等于则加入结果列表，两个指针同时右移

时间复杂度：排序，*O*(*m*log*m*+*n*log*n*)

空间复杂度：*O*(log*m*+log*n*)，空间复杂度主要取决于排序使用的额外空间。



3，无重复字符的最长子串，中等

核心方法：双指针，使用滑动窗口。

难点：初始右指针指向-1的位置，每一次移动右指针，如果右指针指向的元素不在窗口内，则将这个元素添加到字符子串内，后移右指针直到遇到重复的字符；此时删除掉子串中的第一个元素，重复上述步骤，直到遍历完整个字符串。这里所说的左指针，其实就是遍历字符串所用的 **i**

时间复杂度：O(n)

空间复杂度：*O*(∣Σ∣)，∣Σ∣ 表示字符集的大小

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 使用一个字典（滑动窗口）来判断每个字符是否出现过
        S = set()
        n = len(s)
        # 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        # ans 表示最长子串
        rk, ans = -1, 0
        for i in range(n):
            if i != 0:
                # 左指针向右移动一个指针，移除一个字符
                S.remove(s[i - 1])
            while rk + 1 < n and s[rk + 1] not in S:
                # 不断地移动右指针，要保证rk右移后不能溢出，且新加入的字符是不在现存的字符串中
                S.add(s[rk + 1])
                rk += 1
            # 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1)
        return ans
```



560，和为k的子数组，中等

**核心方法：**我们定义 $\textit{pre}[i]$ 为 $[0..i]$ 里所有数的和，则 $\textit{pre}[i]$ 可以由 $\textit{pre}[i-1]$ 递推过来，即

$pre[i]=pre[i−1]+nums[i]$

那么 $[j..i]$  这个子数组和为 $k$ 这个条件可以转化为

$pre[i]-pre[j−1]==k$，移项后   $pre[j-1]==pre[i]-k$

所有只需要统计以 $i$ 结尾的和为 $k$ 的连续子数组个数时，只要统计有多个少前缀和为 $pre[i]-k$ 的 $pre[j]$ 即可

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        count = 0
        mp = collections.defaultdict(int)
        mp[0] = 1
        Sum = 0
        for i in range(len(nums)):
            Sum += nums[i]
            if Sum - k in mp:
                count += mp[Sum - k]
            mp[Sum] += 1  # 这一句比较关键，因为设置了collections.defaultdict(int)
            # 这一句对应两种情况，一种是某cur_sum之前出现过（直接在原来出现的次数上+1即可），
            # 另一种是某cur_sum没出现过（理论上应该设为1，但是因为此处用defaultdict存储，如果cur_sum这个key不存在将返回默认的int，也就是0）
        return count
```



37，解数独，困难

**核心方法**：经典回溯法

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:

        nums = {"1", "2", "3", "4", "5", "6", "7", "8", "9"}
        row = [set() for _ in range(9)]  # 每行设置9个集合
        col = [set() for _ in range(9)]  # 每列设置9个集合
        palace = [[set() for _ in range(3)] for _ in range(3)]  # 设置3*3宫格
        blank = []

        # 初始化，按照行、列、宫 分别存入哈希表
        for i in range(9):
            for j in range(9):
                ch = board[i][j]  # 取出每个位置的字符
                if ch == ".":  # 如果这个位置的字符等于'.'，则将这个位置坐标添加到blank中
                    blank.append((i, j))
                else:
                    row[i].add(ch)  # 否则，将这个字符添加进对应行，列，宫格的集合中
                    col[j].add(ch)
                    palace[i//3][j//3].add(ch)

        def dfs(n):
            if n == len(blank):  # 已经处理完最后一个空位置了，回溯停止
                return True
            i, j = blank[n]  # 取出当前空位置的行，列坐标
            rst = nums - row[i] - col[j] - palace[i//3][j//3]  # 去掉行列宫里的所有数字后剩余的数字集合
            if not rst:  # 如果没得选了，就返回错误，这么选不行
                return False
            for num in rst:
                # 从可选的里面进行选取，选定后，将这个数添加进行列宫里面
                board[i][j] = num
                row[i].add(num)
                col[j].add(num)
                palace[i//3][j//3].add(num)
                # 继续处理下一个位置
                if dfs(n+1):
                    return True
                # 如果下一个位置已经不对了，那么需要做撤回操作
                row[i].remove(num)
                col[j].remove(num)
                palace[i//3][j//3].remove(num)

        dfs(0)
```



387，字符串中的第一个唯一字符，简单

+ 时间复杂度：O(N)
+ 空间复杂度：O(N)

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        dic = {c: s.count(c) for c in set(s)}
        for i, c in enumerate(s):
            if dic[c] == 1:
                return i
        return -1
```

**核心方法**：find() 和 rfind()

+ 时间复杂度：O(N)
+ 空间复杂度：O(1)

```python
class Solution(object):
    def firstUniqChar(self, s: str) -> int:
        # 先假设最小索引为最后的字符索引
        min_unique_char_index = len(s)

        # 已知字符串由小写字母构成，则遍历a-z
        for c in "abcdefghijklmnopqrstuvwxyz":
            i = s.find(c)  # 如果包含子字符串返回开始的索引值，否则返回-1
            # 分别从目标的字符串头和字符串尾查找对应字母的索引；如果两索引相等，则说明是单一字符
            if i != -1 and i == s.rfind(c):
                # s.rfind(c) 表示c在s中最后一次出现的位置
                # 更新最新的最小索引
                min_unique_char_index = min(min_unique_char_index, i)

        # 如果返回值不为最后字符的索引，则返回最小索引值
        # 否则，根据题意，返回-1
        return min_unique_char_index if min_unique_char_index != len(s) else -1
```



454，四数相加，中等

**核心方法**：分组+哈希表

**难点**：将两个数组的每两个数的和作为键，和的次数作为值，建立【和-次数】字典；每次从后两个数组中各选取两个数，看他们的和的负数是否是字典中的键，如果是，就把键对应值累加到结果中

时间复杂度：O(n^2)

空间复杂度：O(n^2)

```python
class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        countAB = collections.Counter(u+v for u in nums1 for v in nums2)
        ans = 0
        for m in nums3:
            for n in nums4:
                if -(m+n) in countAB:
                    ans += countAB[-(m+n)]
        return ans
```



409，最长回文串，简单

**核心方法**：如果数组中有的字符出现的次数为n，那么可利用的个数就为 `n // 2 * 2`，`//` 表示整除，长度中每次更新 `n // 2 * 2`个数；如果出现次数为奇数，则这个奇数可以作为回文的中心，长度数更新+1，其他出现奇数次的数就不能作为中心了

时间复杂度：O(n)

空间复杂度：O(s)，s为set集的大小

```python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        ans = 0
        count = collections.Counter(s)
        for v in count.values():
            ans += v // 2 * 2
            if ans % 2 == 0 and v % 2 == 1:
                ans += 1
        return ans
```

