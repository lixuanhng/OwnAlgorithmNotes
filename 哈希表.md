**739，每日温度，中等**

核心方法：维护一个数组nxt，记录每个温度第一次出现的下标，数组中的元素初始化为无穷大，在遍历过程中更新nxt的值；反向遍历数据，对于每个遍历到的元素，从nxt中找到从这个元素到100中每个温度第一次出现的下标，找到的下标减去当前的元素下标即为下一次比当天高的等待天数，最后向nxt中加入新确定的温度和对应的下标

+ 复杂度：
  + 时间复杂度：`O(mn)`，其中`n`是温度列表的长度，`m`是数组`nxt`的长度
  + 空间复杂度：`O(m)`

```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        n = len(T)
        ans, nxt, big = [0] * n, dict(), 10**9
        for i in range(n - 1, -1, -1):  # 从尾向前遍历
            warmer_index = min(nxt.get(t, big) for t in range(T[i] + 1, 102))  # 求所有大于当前温度的最小下标位置
            if warmer_index != big:
                # 如果这个下标不等于无穷大，则等待天数就是找到的温度的下标-当前温度下标
                ans[i] = warmer_index - i
            nxt[T[i]] = i  # 更新nxt表
        return ans
```

+ <font color=red>（推荐）</font>核心方法：使用单调栈，元素索引入栈，进栈规则为：1、栈为空，2、当前温度比栈顶温度低时；如果当前温度比栈顶温度高，那么栈顶元素出栈，天数就是当前温度对应索引-栈顶元素索引，直到所有小的栈顶元素全部出栈，然后将当前元素索引入栈
+ 复杂度分析
  + 时间复杂度：O(n)
  + 空间复杂度：O(n)

```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        n = len(T)
        res = [0] * n
        stack = []
        for i in range(n):
            tmp = T[i]
            while stack and T[stack[-1]] < tmp:
                idx = stack.pop()
                res[idx] = i - idx
            stack.append(i)
        return res
```



**136，只出现一次的数据，简单**

**核心方法**：使用字典记录元素出现的频率

**复杂度分析**：

+ 时间复杂度：O(n)
+ 空间复杂度：O(n)

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        freq = dict()
        for i in range(len(nums)):
            if nums[i] not in freq.keys():
                freq[nums[i]] = 1
            else:
                freq[nums[i]] += 1
        for k, v in freq.items():
            if v == 1:
                return k
```

**异或运算** （位操作）

+ 异或运算的三个性质：
  + 任何数与自己异或等于0
  + 任何数与0异或等于自己
  + 异或运算满足交换律和结合律
  + 假设共有2m+1个数，只有一个是出现一次的，那么使用异或运算(*a*1⊕*a*1)⊕(*a*2⊕*a*2)⊕⋯⊕(*a* *m*⊕*a* *m*)⊕*a* *m*+1，最后等于*a* m+1，结果就是出现一次的数

+ 时间复杂度：O(n)
+ 空间复杂度：O(1)

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, nums)
```



18，四数之和，中等

**核心方法**：排序，双指针，

**难点**：数组排序，首先使用两重循环取出数组中的前两个数，然后使用双指针遍历后面的数，如果遇到与前面相同的数，则跳过，这样可以避免出现重复四元组；还可以添加一些剪枝操作；假设前面两层循环确定的数为`i`和`j`，那么左指针为`j+1`，右指针为`length-1`。

复杂度分析：

+ 时间复杂度：O(n^3)，其中 n 是数组的长度。排序的时间复杂度是 O(nlogn)，枚举四元组的时间复杂度是 O(n^3)，因此总时间复杂度为 O(n^3 +nlogn)=O(n^3 )。
+ 空间复杂度：O(logn)，其中 n 是数组的长度。空间复杂度主要取决于排序额外使用的空间。此外排序修改了输入数组 nums，实际情况中不一定允许，因此也可以看成使用了一个额外的数组存储了数组 nums 的副本并排序，空间复杂度为 O(n)。

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        quadruplets = list()
        if not nums or len(nums) < 4:
            return quadruplets
        
        # 排序
        nums.sort()
        length = len(nums)
        for i in range(length - 3):
            # 这里设置 length-3 是为了后面还要留出3位
            if i > 0 and nums[i] == nums[i - 1]:
                # 和前一个一样，就跳过
                continue
            if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target:
                # 剪枝，如果挨着的四数之和已经大于target，后面如何遍历都不会等于target，退出循环
                break
            if nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target:
                # 剪枝，第一位和后三位的和已经小于target，遍历中间也不会等于target，跳过
                continue
            for j in range(i + 1, length - 2):
                # 和上一重循环内容相同，处理方式相同
                if j > i + 1 and nums[j] == nums[j - 1]:
                    continue
                if nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target:
                    break
                if nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target:
                    continue
                left, right = j + 1, length - 1
                while left < right:
                    total = nums[i] + nums[j] + nums[left] + nums[right]
                    if total == target:
                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])
                        while left < right and nums[left] == nums[left + 1]:
                            # 注意需要保证移动后，左指针要小于右指针
                            # 和移动方向的下一个一样，就跳过
                            left += 1
                        left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            # 和移动方向的下一个一样，就跳过
                            right -= 1
                        right -= 1
                    elif total < target:
                        left += 1
                    else:
                        right -= 1
        
        return quadruplets
```



49，字符异位词分组，中等

核心方法：对每个字符串进行排序，作为分组的标志字符串（键），将每组的结果添加到这个键对应的列表值中

时间复杂度：O(nklogk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。

空间复杂度：O(nk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的最大长度。需要用哈希表存储全部字符串。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        mp = collections.defaultdict(list)
        for s in strs:
            key = ''.join(sorted(s))
            mp[key].append(key)
        return list(mp.values())
```

核心方法：由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。

时间复杂度：O(n(k+∣Σ∣))，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣=26。 

空间复杂度：O(n(k+∣Σ∣))，记录每个字符串内每个字母出现次数需要Σ，且元组中需要k个位置作为键

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        mp = collections.defaultdict(list)

        for st in strs:
            counts = [0] * 26  # 使用固定大小的数组来记录每个字符串出现的次数
            for ch in st:
                counts[ord(ch) - ord("a")] += 1
            # 需要将 list 转换成 tuple 才能进行哈希
            mp[tuple(counts)].append(st)
        
        return list(mp.values())
```

