# 笔记

常见使用方法：

+ 不同于数组，由于字符串本身是格式固定的，在python中每一次字符串合并的复杂度都是*O(n)*，所以遇到要<font color=red>修改字符串</font>元素的问题，可以先将字符串转化为列表，增删过后再通过join函数将列表转回字符串。

## 541，反转字符串2，简单

### 完成时间：4/13

### 核心方法：反转时使用双指针，选择反转区间时，每次直接向后移动2k个距离

+ 复杂度分析：
  + 时间复杂度：划分区间时的时间复杂度为 O(n/k)，每次反转复杂度是O(k)，最终时间复杂度为O(n)
  + 空间复杂度：创建了一个新的字符串，所以O(n)

```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        p = 0
        res = ''
        while p < len(s):
            if 2*k >= len(s[p: 2*k+p]) >= k:
                # 剩余长度小于等于2k，大于等于k
                res += self.reverse(s[p: 2*k+p], k)
            else:
                # 剩余长度小于k
                res += self.reverse(s[p: 2*k+p], len(s[p: 2*k+p]))
            p += 2*k
        return res

    def reverse(self, sub, k):
        start = 0
        end = k - 1
        l = list(sub)
        while start < end:
            tmp = l[end]
            l[end] = l[start]
            l[start] = tmp
            start += 1
            end -= 1
        return ''.join(l)
```



## 剑指offer.05，替换空格，简单

### 完成时间：4/14

### 核心方法：替换将每个字符处理完毕后加入列表，之后用`"".join()`方法重新组合为字符串

+ 复杂度分析
  + 时间复杂度：O(n)
  + 空间复杂度：O(n)

```python
class Solution:
    def replaceSpace(self, s: str) -> str:
        # 如果直接使用字符串进行添加，时间复杂度比较高
        # 可行的办法是将其转化为列表，添加完成后，再拼接到一起
        # 时间复杂度和空间复杂度都是 O(n)
        res = []
        for c in s:
            if c == ' ': res.append("%20")
            else: res.append(c)
        return "".join(res)
```



## 5，最长回文子串，中等

### 完成时间：4/14

### 核心方法：动态规划

### 难点：`dp[i][j]`表示`s[i..j]`是否为回文串，是为True，否则为False

+ 状态方程 $P(i, j) = P(i+1,j−1)∧(S_i == S_j)$
+ 时间复杂度：
  + 时间复杂度：$O(n^2)$
  + 空间复杂度：$O(n^2)$

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n < 2: return s
        
        max_len = 1
        begin = 0
        # base case
        # 创建一个二维数组，并全部初始化为False
        dp = [[False] * n for _ in range(n)]
        # 表示i，j都是自己，也就是一个字符时，一定是字符串
        for i in range(n):
            dp[i][i] = True
        
        # 递推开始
        # 先枚举子串长度
        for L in range(2, n + 1):  # 这样保证L能取到n
            # 枚举左边界，左边界的上限设置可以宽松一些
            for i in range(n):
                # 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                j = L + i - 1
                # 如果右边界越界，就可以退出当前循环
                if j >= n:
                    break
                    
                if s[i] != s[j]:
                    dp[i][j] = False 
                else:
                    if j - i < 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j - 1]
                
                # 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if dp[i][j] and j - i + 1 > max_len:
                    max_len = j - i + 1
                    begin = i
        return s[begin:begin + max_len]
```

### 核心方法：<font color=red>边界情况</font>对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。

+ 复杂度分析：
  + 时间复杂度：$O(n^2)$
  + 空间复杂度：$O(1)$

```python
class Solution:
    def expandAroundCenter(self, s, left, right):
        # 围绕中心进行扩展
        # left 和 right 都从0开始
        while left >= 0 and right < len(s) and s[left] == s[right]:
            # 从中心向两边进行扩展，知道两边数不相等，或者超出s边界
            left -= 1
            right += 1
        return left + 1, right - 1

    def longestPalindrome(self, s: str) -> str:
        start, end = 0, 0
        for i in range(len(s)):
            # 同一位置作为中心，最终回文子串长度为奇数
            left1, right1 = self.expandAroundCenter(s, i, i)  
            # 相邻两个位置作为中心，最终回文子串为偶数
            left2, right2 = self.expandAroundCenter(s, i, i + 1)  
            if right1 - left1 > end - start:
                start, end = left1, right1
            if right2 - left2 > end - start:
                start, end = left2, right2
        return s[start: end + 1]
```



## 14，最长公共前缀，简单

### 完成时间：4/15

### 核心方法：每次传入上一个找到的最大公共前缀，然后与当前字符串进行比较，返回比较后公共前缀的长度

+ 复杂度分析：
  + 时间复杂度：*O*(*mn*)，其中 *m* 是字符串数组中的字符串的平均长度，*n* 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。
  + 空间复杂度：*O*(*1*)，使用常数空间

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if len(strs) == 0: return ''
        if len(strs) == 1: return strs[0]

        max_str = strs[0]
        n = len(strs)

        for i in range(1, n):
            p = self.lcp(max_str, strs[i])
            max_str = strs[i][:p]
            if not max_str:
                break
        return max_str
        
    
    def lcp(self, str1, str2):
        # 输入两个字符串的最小长度
        min_len = min(len(str1), len(str2))
        p = 0  # 当作两个字符串之间的公共前缀的长度
        while p < min_len and str1[p] == str2[p]:
            p += 1
        return p
```

### 核心方法：纵向遍历，每次比较所有字符串的同一位元素，看是否相同

+ 复杂度和上述相同

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        
        length, count = len(strs[0]), len(strs)
        for i in range(length):
            c = strs[0][i]  # 依次取第一个字符串的所有元素
            if any(i == len(strs[j]) or strs[j][i] != c for j in range(1, count)):
                # 当数字中遍历元素的index已经等于已知所有字符串中长度最小的那个，
                # 或者有数组的对应位置不等于这个位置已知的公共字符串，程序退出
                return strs[0][:i]
        
        return strs[0]
```



## 415，字符串相加，简单

### 核心方法：

+ 两个指针分别从尾至头进行遍历，分别记录每次相加时的和，是否进位，个位是多少，也就是模拟计算过程
+ 如果一个字符串有遍历完了，就令这个字符串这个位置的值为0，等待另一个字符串遍历完
+ 难点：别忘记最后要加上一个进位值

+ 复杂度分析：
  + 时间复杂度： O(max(M,N))，其中 *M*，*N* 为两字符串长度，按位遍历一遍数字（以较长的数字为准）
  + 空间复杂度：O(1)，常数空间

```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        # 两个指针分别指向两个字符串的尾部，从尾向头进行遍历
        p1 = len(num1)-1
        p2 = len(num2)-1
        res = ''
        carry = 0

        while p1 >= 0 or p2 >= 0:
            # 两个指针都小于零时，则停止循环
            n1 =  int(num1[p1]) if p1 >= 0 else 0  # 获得当前数
            n2 =  int(num2[p2]) if p2 >= 0 else 0
            tmp = n1 + n2 + carry  # 当前数求和+上一个进位
            carry = tmp // 10  # 判断是否进位
            res = str(tmp - carry * 10) + res  # 字符串相加
            p1 -= 1
            p2 -= 1
        return str(1) + res if carry else res  # 将最后一个carry加上
```



