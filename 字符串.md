# 笔记

常见使用方法：

+ 不同于数组，由于字符串本身是格式固定的，在python中每一次字符串合并的复杂度都是*O(n)*，所以遇到要<font color=red>修改字符串</font>元素的问题，可以先将字符串转化为列表，增删过后再通过join函数将列表转回字符串。

## 541，反转字符串2，简单

### 完成时间：4/13

### 核心方法：反转时使用双指针，选择反转区间时，每次直接向后移动2k个距离

+ 复杂度分析：
  + 时间复杂度：划分区间时的时间复杂度为 O(n/k)，每次反转复杂度是O(k)，最终时间复杂度为O(n)
  + 空间复杂度：创建了一个新的字符串，所以O(n)

```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        p = 0
        res = ''
        while p < len(s):
            if 2*k >= len(s[p: 2*k+p]) >= k:
                # 剩余长度小于等于2k，大于等于k
                res += self.reverse(s[p: 2*k+p], k)
            else:
                # 剩余长度小于k
                res += self.reverse(s[p: 2*k+p], len(s[p: 2*k+p]))
            p += 2*k
        return res

    def reverse(self, sub, k):
        start = 0
        end = k - 1
        l = list(sub)
        while start < end:
            tmp = l[end]
            l[end] = l[start]
            l[start] = tmp
            start += 1
            end -= 1
        return ''.join(l)
```



## 剑指offer.05，替换空格，简单

### 完成时间：4/14

### 核心方法：替换将每个字符处理完毕后加入列表，之后用`"".join()`方法重新组合为字符串

+ 复杂度分析
  + 时间复杂度：O(n)
  + 空间复杂度：O(n)

```python
class Solution:
    def replaceSpace(self, s: str) -> str:
        # 如果直接使用字符串进行添加，时间复杂度比较高
        # 可行的办法是将其转化为列表，添加完成后，再拼接到一起
        # 时间复杂度和空间复杂度都是 O(n)
        res = []
        for c in s:
            if c == ' ': res.append("%20")
            else: res.append(c)
        return "".join(res)
```



## 5，最长回文子串，中等

### 完成时间：4/14

### 核心方法：动态规划

### 难点：`dp[i][j]`表示`s[i..j]`是否为回文串，是为True，否则为False

+ 状态方程 $P(i, j) = P(i+1,j−1)∧(S_i == S_j)$
+ 时间复杂度：
  + 时间复杂度：$O(n^2)$
  + 空间复杂度：$O(n^2)$

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n < 2: return s
        
        max_len = 1
        begin = 0
        # base case
        # 创建一个二维数组，并全部初始化为False
        dp = [[False] * n for _ in range(n)]
        # 表示i，j都是自己，也就是一个字符时，一定是字符串
        for i in range(n):
            dp[i][i] = True
        
        # 递推开始
        # 先枚举子串长度
        for L in range(2, n + 1):  # 这样保证L能取到n
            # 枚举左边界，左边界的上限设置可以宽松一些
            for i in range(n):
                # 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                j = L + i - 1
                # 如果右边界越界，就可以退出当前循环
                if j >= n:
                    break
                    
                if s[i] != s[j]:
                    dp[i][j] = False 
                else:
                    if j - i < 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j - 1]
                
                # 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if dp[i][j] and j - i + 1 > max_len:
                    max_len = j - i + 1
                    begin = i
        return s[begin:begin + max_len]
```

### 核心方法：<font color=red>边界情况</font>对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。

+ 复杂度分析：
  + 时间复杂度：$O(n^2)$
  + 空间复杂度：$O(1)$

```python
class Solution:
    def expandAroundCenter(self, s, left, right):
        # 围绕中心进行扩展
        # left 和 right 都从0开始
        while left >= 0 and right < len(s) and s[left] == s[right]:
            # 从中心向两边进行扩展，知道两边数不相等，或者超出s边界
            left -= 1
            right += 1
        return left + 1, right - 1

    def longestPalindrome(self, s: str) -> str:
        start, end = 0, 0
        for i in range(len(s)):
            # 同一位置作为中心，最终回文子串长度为奇数
            left1, right1 = self.expandAroundCenter(s, i, i)  
            # 相邻两个位置作为中心，最终回文子串为偶数
            left2, right2 = self.expandAroundCenter(s, i, i + 1)  
            if right1 - left1 > end - start:
                start, end = left1, right1
            if right2 - left2 > end - start:
                start, end = left2, right2
        return s[start: end + 1]
```



## 14，最长公共前缀，简单

### 完成时间：4/15

### 核心方法：每次传入上一个找到的最大公共前缀，然后与当前字符串进行比较，返回比较后公共前缀的长度

+ 复杂度分析：
  + 时间复杂度：*O*(*mn*)，其中 *m* 是字符串数组中的字符串的平均长度，*n* 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。
  + 空间复杂度：*O*(*1*)，使用常数空间

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if len(strs) == 0: return ''
        if len(strs) == 1: return strs[0]

        max_str = strs[0]
        n = len(strs)

        for i in range(1, n):
            p = self.lcp(max_str, strs[i])
            max_str = strs[i][:p]
            if not max_str:
                break
        return max_str
        
    
    def lcp(self, str1, str2):
        # 输入两个字符串的最小长度
        min_len = min(len(str1), len(str2))
        p = 0  # 当作两个字符串之间的公共前缀的长度
        while p < min_len and str1[p] == str2[p]:
            p += 1
        return p
```

### 核心方法：纵向遍历，每次比较所有字符串的同一位元素，看是否相同

+ 复杂度和上述相同

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        
        length, count = len(strs[0]), len(strs)
        for i in range(length):
            c = strs[0][i]  # 依次取第一个字符串的所有元素
            if any(i == len(strs[j]) or strs[j][i] != c for j in range(1, count)):
                # 当数字中遍历元素的index已经等于已知所有字符串中长度最小的那个，
                # 或者有数组的对应位置不等于这个位置已知的公共字符串，程序退出
                return strs[0][:i]
        
        return strs[0]
```



## 415，字符串相加，简单

### 核心方法：

+ 两个指针分别从尾至头进行遍历，分别记录每次相加时的和，是否进位，个位是多少，也就是模拟计算过程
+ 如果一个字符串有遍历完了，就令这个字符串这个位置的值为0，等待另一个字符串遍历完
+ 难点：别忘记最后要加上一个进位值

+ 复杂度分析：
  + 时间复杂度： O(max(M,N))，其中 *M*，*N* 为两字符串长度，按位遍历一遍数字（以较长的数字为准）
  + 空间复杂度：O(1)，常数空间

```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        # 两个指针分别指向两个字符串的尾部，从尾向头进行遍历
        p1 = len(num1)-1
        p2 = len(num2)-1
        res = ''
        carry = 0

        while p1 >= 0 or p2 >= 0:
            # 两个指针都小于零时，则停止循环
            n1 =  int(num1[p1]) if p1 >= 0 else 0  # 获得当前数
            n2 =  int(num2[p2]) if p2 >= 0 else 0
            tmp = n1 + n2 + carry  # 当前数求和+上一个进位
            carry = tmp // 10  # 判断是否进位
            res = str(tmp - carry * 10) + res  # 字符串相加
            p1 -= 1
            p2 -= 1
        return str(1) + res if carry else res  # 将最后一个carry加上
```



## 22，括号生成，中等

### 核心方法：深度优先遍历，递归

### 难点：

+ 左右括号都有大于0个括号可以使用时，才会产生新的分支
+ 产生左分支时，需要保证左括号还有剩余
+ 产生右括号时，需要保证剩余的左括号数量要大于剩余的右括号数量，否则不能添加
+ 当剩余的左右括号都为0时，就可以向列表中添加这个字符串了
+ 复杂度分析：

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        res = []
        cur_str = ''

        def dfs(cur_str, left, right):
            """
            :param cur_str: 从根结点到叶子结点的路径字符串
            :param left: 左括号还可以使用的个数
            :param right: 右括号还可以使用的个数
            :return:
            """
            if left == 0 and right == 0:
                res.append(cur_str)
                return
            if right < left:
                return
            if left > 0:
                dfs(cur_str + '(', left - 1, right)
            if right > 0:
                dfs(cur_str + ')', left, right - 1)

        dfs(cur_str, n, n)
        return res
```



## 6，Z字形变换，中等

### 完成时间：4/17

### 核心方法：遍历数组`s`时，其输出的字符按`numRows`展开后的数组索引刚好是从头至尾，然后再从尾至头

### 难点：数组索引`i`的变化：遍历到尾时，需要`i-=1`，遍历到头时需要`i+=1`，这个转换需要靠flag完成，头尾处进行符号转变

+ 复杂度分析：
  + 时间复杂度：`O(N)`
  + 空间复杂度：`O(N)` 

```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows < 2: return s
        res = ['' for _ in range(numRows)]
        i = 0
        flag = -1
        for c in s:
            res[i] += c
            if i == 0 or i == numRows - 1:
                flag = -flag
            i += flag
        return "".join(res)
```



## 13，罗马数字转整数，简单

### 完成时间：4/17

### 核心方法：构造所有罗马数字对应阿拉伯数字的哈希表，哈希表中两个长度的罗马数字对应的数为`真实数-前一位的数的阿拉伯数结果`

### 难点：每次处理的子串为两个（第一次除外），若两个子串组合在字典中，则返回其值，不在则返回其子串中右边串的本值

+ 复杂度分析
  + 时间复杂度：`O(n)`
  + 空间复杂度：`O(n)`

```python
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {'I':1, 'IV':3, 'V':5, 'IX':8, 'X':10, 'XL':30, 'L':50, 
             'XC':80, 'C':100, 'CD':300, 'D':500, 'CM':800, 'M':1000}
        # d 中记录的是所有罗马数字的组合及对应的数值
        # 如果罗马数字是两位，则这里的数值为真实值-前一个数值的值
        Sum = 0
        for i, n in enumerate(s):
            # cur 表示当前的子串，max函数为了方式出现(-1, 0)的情况
            # 也就是说，i=0时处理的子串是一个字符，之后处理的都是两个字符
            cur = s[max(i-1, 0): i+1]
            # 使用python的字典的get方法，找到返回对应值，没找到则返回默认值
            val = d.get(cur, d[n])
            Sum += val
        return Sum
```



## 8，字符串转换整数，中等

### 完成时间：4/17

### 核心方法：状态转移，记录状态的自动机，每个状态如下：

|           | ' '   | +/-    | Number    | Other |
| --------- | ----- | ------ | --------- | ----- |
| start     | start | signed | in_number | end   |
| signed    | end   | end    | in_number | end   |
| in_number | end   | end    | in_number | end   |
| end       | end   | end    | end       | end   |

+ 说明：表中的行表示不同状态，列表示输入的字符，一个状态 $s$ 在输入字符 $c$ 的条件下，变为另一个状态 $s^‘$；比如，如果当前的状态为`start`，如果输入的字符是`+/-`，那么这个状态就会变为`signed`。

+ 将上表这个结果添加到代码中
+ 注意：
  + 对于number状态，需要计算这个值，并判断是否在两个边界内
  + 对于signed状态，等所有结果都计算完毕后，再添加符号
+ 复杂度分析
  + 时间复杂度：O(n)
  + 空间复杂度：O(1)

```python
INT_MAX = 2 ** 31 - 1  # 设定最大值和最小值的范围
INT_MIN = -2 ** 31

class Automaton:
    def __init__(self):
        self.state = 'start'  # 指定初始状态
        self.sign = 1  # 设定初始符号
        self.ans = 0  # 计算结果
        self.table = {
            'start': ['start', 'signed', 'in_number', 'end'],
            'signed': ['end', 'end', 'in_number', 'end'],
            'in_number': ['end', 'end', 'in_number', 'end'],
            'end': ['end', 'end', 'end', 'end'],
        }
        
    def get_col(self, c):
        # 通过输入的字符来确定table中状态的索引
        if c.isspace():
            return 0
        if c == '+' or c == '-':
            return 1
        if c.isdigit():
            return 2
        return 3

    def get(self, c):
        self.state = self.table[self.state][self.get_col(c)]
        if self.state == 'in_number':
            # 如果状态为number，则计算这个值
            # 前面的数乘10，个位数为新的字符数
            self.ans = self.ans * 10 + int(c)
            self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(self.ans, -INT_MIN)
        elif self.state == 'signed':
            # 查看符号
            self.sign = 1 if c == '+' else -1

class Solution:
    def myAtoi(self, str: str) -> int:
        automaton = Automaton()
        for c in str:
            automaton.get(c)
        # 最后给计算结果加上符号
        return automaton.sign * automaton.ans
```

