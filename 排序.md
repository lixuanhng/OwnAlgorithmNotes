剑指offer45，把数组排成最小的数，中等

核心方法：如果将所有可能的结果都排出来，再进行排序，那么可能面临着数值溢出的异常问题。这里可以使用冒泡排序的最佳优化方式，核心在于将<font color=red>两两排列最大的放到尾部，这样算法收敛后就能够排列出最小的数字</font>。字符串`a`+`b`大于`b`+`a`的情况下，则交换`a`和`b`。

+ 比如 "210" > "102"，那么一定能得到 210 > 102 么？

  答案是肯定的：首先拼接成的两个字符串一定是等长的。等长的字符串在比较的时候，是按照字符串的各个字符从前向后逐个比较的，所以相当于先比较了百分位，然后比较十分位，最后比较个位。所以在字符串等长的情况下，字符串大，那么对应的整型也更大。但两个不等长的字符串就没有这个结论了， 比如 "2" > "10"，但是 2 < 10。

时间复杂度：$O(n^2)$

空间复杂度：O(1)

```python
class Solution:
    def minNumber(self, nums: List[int]) -> str:
        n = len(nums)
        swapped = True
        last_idx = n - 1      # 最后一个没有经过排序的元素下标
        swapped_idx = -1      # 上次发生交换的位置
        while swapped:        # 上一步没有交换时，这一步退出while循环
            swapped = False
            for i in range(last_idx):
                if str(nums[i]) + str(nums[i+1]) > str(nums[i+1]) + str(nums[i]):
                    tmp = nums[i]
                    nums[i] = nums[i+1]
                    nums[i+1] = tmp
                    swapped = True
                    swapped_idx = i    # 每轮只要发生了交换，就维护一次发生交换的位置
            last_idx = swapped_idx # 最后一个没有经过排序的元素下标就是最后一次发生交换的位置
        nums = [str(item) for item in nums]
        return ''.join(nums)
```



179，最大数，中等

核心方法：和上一个【把数组排成最小数】的解法都一样，都使用了【冒泡排序】，只需要把中间的交换条件修改为当前的两个排列的组合小于修改顺序后的两个排列时，再进行交换。要注意的是如果最后得到的字符串为多个0，那么返回只需要返回一个0，因为多个0在数字中是不合法的。

时间复杂度：$O(n^2)$

空间复杂度：O(1)

```python
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        # 使用冒泡排序
        n = len(nums)
        swapped = True
        last_idx = n - 1
        swapped_idx = -1
        while swapped:
            swapped = False
            for i in range(last_idx):
                if str(nums[i]) + str(nums[i+1]) < str(nums[i+1]) + str(nums[i]):
                    tmp = nums[i]
                    nums[i] = nums[i+1]
                    nums[i+1] = tmp
                    swapped = True
                    swapped_idx = i
            last_idx = swapped_idx
        nums = [str(item) for item in nums]
        if set(nums) == {'0'}: return '0'
        return ''.join(nums)
```



283，移动零，

核心方法：双指针。两个指针同时向前走，如果一个指向的非零元素，一个指向0，那么就交换两个元素。指向非零元素的指针在每轮循环中都要移动，但只要指向非零的指针指向非零元素，那么就移动指向零的指针。也就是说，这种算法会使得前面所有的零全部移到数组最后的位置。

时间复杂度：O(n)

空间复杂度：O(1)

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        i, j = 0, 0
        while j < len(nums):
            if nums[j] != 0:
                if nums[i] == 0:
                    # 进行交换，前提是一个指针指向非零，一个指向0
                    nums[i] = nums[j]
                    nums[j] = 0
                i +=1
            j += 1
        return nums
```



912，排序数组，中等

核心方法：使用希尔排序。

+ 时间复杂度：它的平均复杂度界于 $O(n)$ 到 $O(n^2)$ 之间，普遍认为它最好的时间复杂度为 $O(n^{1.3})$ 

+ 空间复杂度为 O(1)，只需要常数级的临时变量

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        gap = n // 2  # 间隔序列，在希尔排序中我们称之为增量序列
        while gap > 0:
            # 相比【插入排序】，主要变化是在最外层嵌套了一个缩小增量的 for 循环；并且插入时不再是相邻数字挪动，而是以增量为步长挪动。
            # 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组
            for i in range(gap, n):
                # 当前待插入的元素
                curr = nums[i]
                # 该组前一个数字的索引
                preIdx = i - gap
                while preIdx >= 0 and curr < nums[preIdx]:
                    # 将大于当前元素的元素向后移
                    nums[preIdx + gap] = nums[preIdx]
                    preIdx -= gap
                nums[preIdx + gap] = curr
            gap = gap // 2
        return nums
```

核心方法：快速排序（<font color=red>推荐</font>）

+ 介绍：
  + 通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序，以此使整个序列达到有序。

+ 递归函数：
  + 函数`randomized_quicksort(nums, l ,r)`为对`nums`数组里的`[l, r]`的部分进行排序，每次先调用划分函数`randomized_partition`对`nums`数组里的`[l, r]`的部分进行划分，并返回分界值的下标`pos`，然后记录递归调用`randomized_quicksort(nums, l ,pos-1)`和`randomized_quicksort(nums, pos-1, r)`
+ 划分函数：
  + 初始状态下需要确定第一个分界值，称之为`pivot`。这里使用随机划分的方法，对当前划分区间 `[l, r]` 里的数等概率随机一个作为我们的主元。<font color=red>再将主元放到区间末尾，进行划分。</font>
  + 整个划分函数 `partition` 主要涉及两个指针 `i` 和 `j`，一开始 `i = l - 1`，`j = l`。我们需要实时维护两个指针使得任意时候，对于任意数组下标 `k`，我们有如下条件成立：
    1. $l \le k \le i$ 时， $nums[k] \le pivot$ 
    2. $i+1 \le k \le j-1$ 时， $nums[k] > pivot$
    3. $k == r$ 时，$nums[k] = pivot$
  + <font color=red> 后续的操作就是要让每一次排序完的数组满足上述条件 </font>
  + 每次开始排序前，`j`从`l`开始遍历，如果`nums[j]`小于`nums[r]`，那么`i+=1`；由于`i`的初始值为`-1`，当`+1`后就会变为`0`，然后`nums[0]`就可以取值了。这时对`nums[i]`和`nums[j]`进行交换，交换时，`nums[j]`表示当前遍历位置处小于`nums[r]`（也就是`pivot`，这里已经进行了交换）的数，`nums[i]`表示从左至右第一个大于`nums[r]`的数。遍历完成后，就能在`i`处形成一个区分，`nums[0..i]`处为小于`pivot`的，`nums[i+1..n-2]`处为大于`pivot`。
  + 此时`i`需要向前走一步，走这一步是为了将`nums[i]`与`nums[r]`进行交换，也就是`nums[i]`与`pivot`（中间值）进行交换，这样从左到右最大的数就被换到了末尾。交换完成后，`pivot`对应的索引就是`i`，`i`的左边都是小于`pivot`的，`i`的右边都是大于`pivot`的，此时的区间就划分好了。
+ 时间复杂度：O(nlogn)
+ 空间复杂度：O(h)，其中h为快速排序中递归调用的层数。由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需 O(n) 的空间，最优情况下每次都平衡，此时整个递归树高度为 logn，空间复杂度为 O(logn)。

```python
class Solution:
    def randomized_partition(self, nums, l, r):
        # 随机选取数组中的一个数作为pivot
        pivot = random.randint(l, r)  
        # 将【pivot】与【末尾元素】进行交换
        nums[pivot], nums[r] = nums[r], nums[pivot]
        i = l - 1
        for j in range(l, r):
            if nums[j] < nums[r]:
                i += 1
                # 【最靠前的大数】与【当前遍历到的小数】进行交换
                nums[j], nums[i] = nums[i], nums[j]
        i += 1
        # 【当前最靠前的大数】与【末尾pivot】进行交换
        nums[i], nums[r] = nums[r], nums[i]
        # 返回的是【当前pivot】
        return i

    def randomized_quicksort(self, nums, l, r):
        if r - l <= 0:
            return
        mid = self.randomized_partition(nums, l, r)
        self.randomized_quicksort(nums, l, mid - 1)
        self.randomized_quicksort(nums, mid + 1, r)

    def sortArray(self, nums: List[int]) -> List[int]:
        self.randomized_quicksort(nums, 0, len(nums) - 1)
        return nums
```

核心方法：堆排序。

首先将待排序的序列构建最大堆。使得每个父节点的元素都大于子节点的元素。序列最大值为堆顶元素，然后将其与末尾元素进行交换，使末尾元素为最大值。在调整堆顶元素使得剩下的n-1个元素仍为最大堆。重复上述步骤。

总结起来是两步，首先进行堆化，然后取出最大值后，重新进行堆化，直到堆为空

+ 完全二叉树的性质
  + 完全二叉树的第 `i` 个节点，其左子节点索引为 `left = 2 * i - 1`，右子节点为 `right = left + 1`
+ 时间复杂度：O(nlogn)
+ 空间复杂度：O(1)

```python
class Solution:
    def max_heapify(self, heap, root, heap_len):
        """
        构建最大堆
        Arguments:
        	heap: 数组元素
        	root: 当前在排的元素的索引
        	heap_len: 未排序的数组长度，也就是为排序的元素个数
        """
        p = root  # 当前节点（根节点）的索引
        while p * 2 + 1 < heap_len:  # 需要保证当前左子节点的索引不超过为排序的元素个数
            # 分别定义左子节点和右子节点
            l, r = p * 2 + 1, p * 2 + 2
            
            # 找到根结点，左子节点，右子节点的最大值
            # nex 用来记录左子结点、右子结点二者中的最大值下标
            if heap_len <= r or heap[r] < heap[l]:
                # r 的值已经超出边界了，或者r对应的数小于l对应的数，则最大索引为l
                nex = l
            else:
                nex = r
            if heap[p] < heap[nex]:
                # 如果最大值大于当前根结点，则将两个节点进行互换，并更新根结点索引
                heap[p], heap[nex] = heap[nex], heap[p]
                p = nex
            else:
                # 否则退出循环
                break
        
    def build_heap(self, heap):
        # 初始化最大堆
        for i in range(len(heap) - 1, -1, -1):
            self.max_heapify(heap, i, len(heap))

    def heap_sort(self, nums):
        self.build_heap(nums)
        # 将堆顶元素与末尾元素进行交换，然后重建堆
        for i in range(len(nums) - 1, -1, -1):
            nums[i], nums[0] = nums[0], nums[i]
            # 每次元素互换后，i表示的就是剩下没有排序的数据长度，i之后的都是已经排好的
            self.max_heapify(nums, 0, i)
            
    def sortArray(self, nums: List[int]) -> List[int]:
        # 调用堆排序
        self.heap_sort(nums)
        return nums
```

核心方法：归并排序

+ 问题：如何将两个有序列表合并成一个有序列表
  + 如何遍历一次完成合并操作
    + 两个数组已经是有序的了，那么从一个数组中向另一个数组中插入时，已经插入的位置就不会再插入了。每次插入时，只需要从上一个插入的位置开始继续向后寻找插入位置即可。
  + 在插入新数字时，原数组需要不断腾出位置，这个过程可能会增加一轮新的遍历
    + 替代方案：只要创建一个新数组，并使用两个指针来遍历原有的两个数组，不断将较小的数添加进新数组，并移动相应指针。
+ 没有有序数组应该怎么办？
  + 将无序数组不断进行拆分，直到只剩下一个数字时，就可以认为这个数字就是有序的
  + 将 1 个数字组成的有序数组合并成一个包含 2 个数字的有序数组，再将 2 个数字组成的有序数组合并成包含 4 个数字的有序数组...直到整个数组排序完成，这就是归并排序的思想
+ 时间复杂度：O(nlogn)
+ 空间复杂度：O(n)

```python
class Solution:
    def merge_sort(self, nums, l, r):
        if r == l:
            return
        # 使用分治递归
        mid = (r + l) // 2
        self.merge_sort(nums, l, mid)
        self.merge_sort(nums, mid+1, r)
        i, j = l, mid+1
        tmp = []  # 创建一个临时数组，用来临时存放本次排序的结果
        while i <= mid or j <= r:
            # 这里的循环条件终止条件是，两个数组必须全部遍历完成
            if i > mid or (j <= r and nums[j] < nums[i]):
                # 当i已经遍历完成了，或者j没有遍历完，且j对应的数小于i对应的数
                tmp.append(nums[j])
                j += 1
            else:
                tmp.append(nums[i])
                i += 1
        # 将当前排好序的结果替换掉原来的数组元素
        nums[l: r+1] = tmp

    def sortArray(self, nums):
        self.merge_sort(nums, 0, len(nums)-1)
        return nums
```





506，相对名次，简单

核心方法：使用希尔排序。

```python
class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        # 初始化每个分数对应的排名（按照当前排名）
        rank = dict()
        for i, s in enumerate(score):
            rank[s] = i
        
        # 使用希尔排序
        n = len(score)
        gap = n // 2
        while gap > 0:
            for i in range(gap, n):
                curr = score[i]
                preIdx = i - gap
                while preIdx >= 0 and curr > score[preIdx]:
                    score[preIdx + gap] = score[preIdx]
                    preIdx -= gap
                score[preIdx + gap] = curr
            gap = gap // 2
		
        # i 表示当前名次，v 表示各个分数，score 为排序后的结果
        title = ("Gold Medal", "Silver Medal", "Bronze Medal")
        res = [0] * n
        for i, v in enumerate(score):
            if i < 3:
                # 前三个分别赋予奖牌名称
                res[rank[v]] = title[i]
            else:
                # 之后的赋予新名次+1
                res[rank[v]] = str(i+1)
        return res
```



剑指offer51，数组中的逆序对，困难

核心方法：归并排序。在合并两个递增的有序数组时，如果右边的数字比左边的小，则说明左边数组中尚未合并的数字与右边数组的这个数字都可以组成逆序对，这个逆序对数量就是左边数组当前索引到数组末尾的元素个数（因为是递增的），反之，逆序对的数量不增加。

我们指定左右递增待合并的数组的指针分别为 `lPtr` 和 `rPtr`。

我们发现用这种「算贡献」的思想在合并的过程中计算逆序对的数量的时候，只在 `lPtr` 右移的时候计算（也就是左指针指向元素大于右指针指向元素时），是基于这样的事实：当前 `lPtr` 指向的数字比 `rPtr` 小，但是比 `R` 中 `[0 ... rPtr - 1]` 的其他数字大，`[0 ... rPtr - 1]` 的其他数字本应当排在 lPtr 对应数字的左边，但是它排在了右边，所以这里就贡献了 rPtr-(mid+1) 个逆序对。

原则：<font color=red>谁小移动谁的指针，逆序对的个数就是右边数组中有多少个比左数组的指针对应元素小的数，所以贡献度的计算是放在移动左边指针这里的</font>

归并排序是稳定的

时间复杂度：O(nlogn)  与归并排序相似

空间复杂度：O(n)  使用了一个临时数组

```python
class Solution:
    def mergeSort(self, nums, tmp, l, r):
        if l >= r:
            return 0
		# 进行分治
        mid = (l + r) // 2
        inv_count = self.mergeSort(nums, tmp, l, mid) + self.mergeSort(nums, tmp, mid + 1, r)
        # 分别定义左数组指针，右数组指针，临时数组的指针，全部指向数组的头部
        i, j, pos = l, mid + 1, l
        while i <= mid and j <= r:
            if nums[i] <= nums[j]:
                tmp[pos] = nums[i]
                i += 1
                # 与归并的区别就在于这里，需要记录一次逆序对的贡献度
                inv_count += (j - (mid + 1))
            else:
                tmp[pos] = nums[j]
                j += 1
            pos += 1
        
        # 当两个指针有一个遍历完毕时，需要将另一个没遍历完的遍历完
        # 当然在遍历过程中，遍历左边数组时需要考虑计算贡献度，右边数组只需要赋值就可以了
        for k in range(i, mid + 1):
            tmp[pos] = nums[k]
            inv_count += (j - (mid + 1))
            pos += 1
        for k in range(j, r + 1):
            tmp[pos] = nums[k]
            pos += 1
        # 将临时数组的结果赋值给原始数组
        nums[l:r+1] = tmp[l:r+1]
        return inv_count  # 返回数据合并的结果

    def reversePairs(self, nums: List[int]) -> int:
        n = len(nums)
        tmp = [0] * n  # 创建临时数组，
        # 类似归并排序
        return self.mergeSort(nums, tmp, 0, n - 1)
```

