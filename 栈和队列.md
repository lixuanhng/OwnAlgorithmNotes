## 笔记

1190，反转每对括号间的子串，中等

核心方法：使用栈，只要不是遍历到右括号，就入栈；遇到右括号，则反转内层字符串，然后再加入栈顶

难点：注意内层字符串反转完成后，需要弹出栈顶元素，因为此时的栈顶元素为左括号

复杂度分析：

+ 时间复杂度：O(n) n为字符串的长度
+ 空间复杂度：O(k) k为字符串的长度

```python
class Solution:
    def reverseParentheses(self, s: str) -> str:
        stack = []
        for c in s:
            if c != ')':
                stack.append(c)
            else:
                tmp = []
                while stack and stack[-1] != '(':
                    tmp.append(stack.pop())
                stack.pop()  # 弹出栈顶元素
                stack += tmp
        return ''.join(stack)
```



224，基本计算器，困难

核心方法：栈。当括号展开后，<font color=red>如果原括号前面是负号，那么远括号内的数字都要进行符号反转。</font>栈中存放的是从当前位置向前算，所有符号的综合影响的结果。遍历到哪个位置，如果这个位置是`+`号，那么就直接取出最近的符号；如果这个位置是`-`减号，那么就直接取出最近的符号的符号；如果这个位置是左括号，那么将最近符号压入栈中；如果是右括号，则弹出栈顶符号。

难点：遍历到哪里，就计算到哪里。注意，可能存在两个数是大于9的情况，此时要上一个结果`*10`。每遇到一个左括号，向栈中压入这个左括号前的符号；每遇到一个右括号，从栈中弹出一个符号

复杂度分析

+ 时间复杂度：O(n)
+ 空间复杂度：O(n)

```python
class Solution:
    def calculate(self, s: str) -> int:
        ops = [1]  # 初始化栈，栈里只存放符号
        sign = 1  # 初始化符号为1

        ret = 0  # 结果
        n = len(s)
        i = 0
        while i < n:
            if s[i] == ' ':  # 遇到空格，跳过
                i += 1
            elif s[i] == '+':  # 遇到+号时，取出栈顶符号
                sign = ops[-1]
                i += 1
            elif s[i] == '-':  # 遇到-号时，取出栈顶符号的负值
                sign = -ops[-1]
                i += 1
            elif s[i] == '(':  # 遇到左括号，向栈中压入当前符号
                ops.append(sign)
                i += 1
            elif s[i] == ')':  # 遇到右括号，弹出一个符号，说明此时括号内的计算完毕，括号前的那个符号就不要了
                ops.pop()
                i += 1
            else:  # 遇到数字的情况
                num = 0
                while i < n and s[i].isdigit():
                    num = num * 10 + ord(s[i]) - ord('0')  # 得到两数之和
                    i += 1
                ret += num * sign  # 将当前和添加进结果中
        return ret
```



1047，删除字符串中的所有相邻重复项，简单

核心方法：栈。栈不为空且栈顶元素等于当前元素时，栈弹出一个元素；否则将当前元素入栈。

复杂度分析：

+ 时间复杂度：O(n)
+ 空间复杂度：O(n)

```python
class Solution:
    def removeDuplicates(self, S: str) -> str:
        stack = list()
        for ch in S:
            if stack and stack[-1] == ch:
                stack.pop()
            else:
                stack.append(ch)
        return ''.join(stack)
```



剑指offer09，用两个栈实现队列，简单

核心方法：两个栈，栈1用来添加，栈2用来删除。对于在队尾添加的情况，直接添加进栈1；对于队头删除的情况，首先判断栈2是否不为空，如果不为空则直接出栈；如果为空，判断栈1是否为空，如果为空，则返回-1；如果栈1不为空，将栈1中的数依次出栈添加进栈2，然后栈2出栈一个数

复杂度分析：

+ 时间复杂度：添加O(1)，删除可能导致栈1中元素全部出栈，复杂度为O(n)
+ 空间复杂度：O(n)，最差情况下，两个栈各保存n各元素

```python
class CQueue:
    def __init__(self):
        self.A, self.B = [], []

    def appendTail(self, value: int) -> None:
        self.A.append(value)

    def deleteHead(self) -> int:
        if self.B:
            return self.B.pop()
        elif not self.A:
            return -1
        else:
            while self.A:
                self.B.append(self.A.pop())
            return self.B.pop()
```



103，二叉树的锯齿形层序遍历，中等

核心方法：广度优先搜索，队列，双端队列

难点：每次将当前节点的左右子节点存入队列。当这个队列不为空时，根据当前队列个数，新建双端队列，通过树的层级奇偶形确定当前节点的值是添加在双端队列的头部还是尾部。对队列中每个元素处理时，双端队列的结果都要转化为列表，添加进结果中

时间复杂度：O(n) 每个节点都会被遍历一次

空间复杂度：两个队列需要维护，O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []  # 特殊情况处理
        # 初始化 queue 队列先存入根节点
        queue = deque()
        queue.append(root)
        
        # 用来标记当前层是偶数层还是奇数层
        is_even_level = True
        # 结果列表
        ans = []
        
        # 队列不为空时，开始进行遍历
        while queue:
            # 声明双端队列 level_queue
            level_queue = deque()
            # 先计算 queue 的长度 size
            size = len(queue)
            
            # 取出 size 个元素
            for _ in range(size):
                # 取出节点
                node = queue.popleft()
                # 偶数层，将节点值插入到 level_queue 尾部
                if is_even_level:
                    level_queue.append(node.val)
                # 奇数层，将节点值插入到 level_queue 头部
                else:
                    level_queue.appendleft(node.val)
                # 将下一层的节点存放到 queue 中
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            # 这里注意，将双端队列转换为列表的形式，存入结果列表中
            ans.append(list(level_queue))
            # 维护更新 is_even_level
            is_even_level = not is_even_level
        
        return ans
```



394，字符串解码，中等

核心方法：使用栈。

难点：创建临时结果`res`和乘积变量`multi`，分别记录拆开括号后（即重复k次后）的结果和`[`前的乘数

时间复杂度：O(n)

空间复杂度：极端情况需要线性空间 O(n)

```python
class Solution:
    def decodeString(self, s: str) -> str:
        stack, res, multi = [], "", 0
        for c in s:
            if c == '[':
                # 当遇到前括号时，将括号前的乘数和临时结果入栈
                stack.append([multi, res])
                res, multi = "", 0  # 重制乘数和临时结果
            elif c == ']':
                # 当遇到后括号时，出栈，记录乘数和上一次临时结果
                cur_multi, last_res = stack.pop()
                # 当前字符串重复并与上一个临时结果进行拼接
                res = last_res + cur_multi * res
            elif '0' <= c <= '9':
                # 等于数字时需要整理乘数，乘10是为了保证multi不止个位
                multi = multi * 10 + int(c)            
            else:
                # 同一括号内的字母要进行拼接
                res += c
        return res
```

