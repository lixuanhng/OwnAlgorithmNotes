53，最大自序和，简单

dp[i] 只跟 dp[i-1] 有关，所以可以使用一个变量表示上一个值，每次取更新后的pre和上一次结果cur的最大值最为当前维护的最大值

时间复杂度：O(n)

空间复杂度：O(1)

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        cur = -10**5
        pre = 0
        for i in range(len(nums)):
            # 要么与前面合并，要么自己开头
            pre = max(pre + nums[i], nums[i])
            cur = max(cur, pre)
        return cur
```



322，零钱兑换，中等

核心方法：动态规划

难点：dp[i] 定义为组成金额 i 所需的最少的硬币数量，dp[i] 对应的转移方程为

$F(i) = min_{j=0...n-1}F(i - c_j) + 1$

其中 $c_j$ 代表的是第 j 枚硬币的面值，当枚举最后一枚硬币面额是$c_j$，那么需要从 $i - c_j$这个金额的状态$F(i - c_j)$转移过来，在算上枚举的这枚硬币的数量1的贡献

+ 复杂度分析
  + 时间复杂度：O(Sn)，其中 S 是金额，n 是面额数。我们一共需要计算 O(S) 个状态，S 为题目所给的总金额。对于每个状态，每次需要枚举 n 个面额来转移状态，所以一共需要 O(Sn) 的时间复杂度。
  + 空间复杂度：*O*(*S*)。数组 *dp* 需要开长度为总金额 *S* 的空间。

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # 初始化，定义dp数据的每个位置为无穷大，因为要求最小数量
        dp = [float('inf')] * (amount + 1)
		# 边界条件：金额为零的时候就没有面额可用
        dp[0] = 0
        
        for coin in coins:
            # 获取一个面额
            for x in range(coin, amount + 1):
                # 从该面额到全金额中获取一个面额
                dp[x] = min(dp[x], dp[x - coin] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1 
```



72，编辑距离，困难

核心方法：动态规划（解决两个字符串的动态规划问题，一般都是用两个指针i，j分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模）

难点：

`dp[i][j]`定义为`word1[0..i-1]`变为`words[0..j-1]`的最小操作数，也就是`word1`的前`i`个字符串和`word2`的前`j`个字符串的编辑距离

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)
        # 使用dp数组，dp[i][j]表示从word1[..i]变为word2[..j]需要的最小操作数
        # 因为会考虑到两个数组为空的情况，所以dp数组的两个维度各加一个
        dp = [[float('inf')] * (n+1) for _ in range(m+1)]
    
        # 如果word1不为空，word2为空，那么需要都删掉，dp[m][0] = m
        for i in range(m+1):
            dp[i][0] = i
        # 如果word1为空，word2不为空，那么直接插入就行了，dp[0][n] = n
        for j in range(n+1):
            dp[0][j] = j
		# 如果word1，word2都为空，那么dp[0][0] = 0（在上面两种情况中都被包含了）
            
        for i in range(1, m+1):
            for j in range(1, n+1):
                # 由于i 和 j 是从1开始取的，所以回到两个数组中时，需要各自-1才能取到第0位
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]  # 跳过操作
                else:
                    dp[i][j] = min(dp[i][j-1] + 1,   # 插入操作
                                   dp[i-1][j] + 1,   # 删除操作
                                   dp[i-1][j-1] + 1) # 替换操作
        return dp[m][n]
```

（<font color=red>推荐使用</font>）上述的，当两个字符不能匹配时，插入操作，删除操作，替换操作能够解释dp数组变化的情况，也就是两个指针分别从两个字符串的末尾开始向前移动时的操作。

另外一种解释是，两个字符串的编辑距离可以转化为以下三种操作：

+ 在单词`A`中插入一个字符：`D[i][j-1]` 为 `A` 的前` i` 个字符和 `B` 的前` j - 1` 个字符编辑距离的子问题。即对于 `B` 的第` j` 个字符，我们在 `A` 的末尾添加了一个相同的字符
+ 在单词`B`中插入一个字符：`D[i-1][j]` 为 `A` 的前 `i - 1` 个字符和 `B` 的前 `j` 个字符编辑距离的子问题。即对于 `A` 的第 `i` 个字符，我们在 `B` 的末尾添加了一个相同的字符
+ 修改单词A的一个字符：`D[i-1][j-1]` 为 `A` 前 `i - 1` 个字符和 `B` 的前 `j - 1` 个字符编辑距离的子问题。即对于 `B` 的第 `j` 个字符，我们修改 `A` 的第 `i` 个字符使它们相同。如果 `A` 的第 `i` 个字符和 `B` 的第 `j` 个字符原本就相同，那么我们实际上不需要进行修改操作。
+ 此时的状态转移方程为：
  + 若 `A` 和 `B` 的最后一个字母相同：
    + `dp[i][j] = min(dp[i][j-1] + 1, dp[i-1][j] + 1, dp[i-1][j-1])`
  + 若 `A` 和 `B` 的最后一个字母不同：
    + `dp[i][j] = min(dp[i][j-1] + 1, dp[i-1][j] + 1, dp[i-1][j-1] + 1)`
  + 代码可以表示为

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n = len(word1)
        m = len(word2)
        
        # 有一个字符串为空串，那么其操作数就是另一个字符串的长度
        if n * m == 0:
            return n + m
        
        # DP 数组
        D = [[0] * (m + 1) for _ in range(n + 1)]
        
        # 边界状态初始化（与上同）
        for i in range(n + 1):
            D[i][0] = i
        for j in range(m + 1):
            D[0][j] = j
        
        # 计算所有 DP 值
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                # 针对上面第二种状态转移
                left = D[i - 1][j] + 1
                # 针对上面第一种状态转移
                down = D[i][j - 1] + 1
                # 针对上面第三种状态转移
                left_down = D[i - 1][j - 1] 
                if word1[i - 1] != word2[j - 1]:
                    left_down += 1
                # 取最小
                D[i][j] = min(left, down, left_down)
        
        return D[n][m]
```



300，最长递增子序列，中等

核心方法：动态规划，定义`dp[i]`为`nums[0..i]`的最长递增子序列的长度

难点：这里实际处理的是对象为`i`，但是与`nums[i]`比较的是索引`i`之前的所有的数。这里的状态转移是，找到当前最大递增子序列长度`dp[i]`，和比`nums[i]`小的数对应的索引`j`对应的最大递增子序列长度，谁大取谁

时间复杂度：$O(n^2)$

空间复杂度：$O(n)$

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        # 边界条件：dp[0] = 1，对dp数组的所有位置全部进行初始化
        dp = [1] * len(nums)
        # 因为dp[0] = 1，所以i从1开始取
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
        return max(dp)
```

对于时间复杂度为$O(nlogn)$的处理方式，可以参考如下方式：有一副扑克牌，我们像遍历数组那样从左至右一张张来处理这些扑克牌，最终要把这副牌分成若干份；处理的原则为：只能把点数小的牌压到点数比它大或者和它相等的牌上；如果当前牌点数较大没有可以放置的堆，就新建一个堆，把这张堆放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。

按照上述规则执行，可以算出最长递增子序列，牌的堆数就是最长递增子序列的长度。



1143，最长公共子序列，中等

核心方法：子序列问题，都要考虑使用动态规划的方法

难点：

+ 定义：`dp[i][j]`表示`text1[0..i-1]`和`text[0..j-1]`的最长公共子序列
+ base case：`dp[0][..]`和`dp[..][0]`都为0，有一个为空，那么最长公共子序列就为0
+ 如果`text1[i] == text2[j]`，那么`dp[i][j] = dp[i-1][j-1] + 1`
+ 如果`text1[i] != text2[j]`，那么说明两个字符串中有一个字符串是不在公共子序列中，需要看前一个在不在，也就是选取前面的最大值。没有选到的就是不在公共子序列里的字符。`dp[i][j] = max(dp[i][j-1], dp[i-1][j])`

+ 时间复杂度：O(mn)，m，n分别是text1，text2的长度
+ 空间复杂度：O(mn)，主要来自于dp数组

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n+1) for _ in range(m+1)]  # 考虑到了字符串为空的情况，行列都要+0
        # already initialize the element to 0
        for i in range(1, m+1):  # 因为加了0，就要取到m，所以这里是m+1
            for j in range(1, n+1):
                if text1[i-1] == text2[j-1]:  # 使用索引减1，是因为索引从1开始，但要取到0
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[m][n]
```



32，最长有小括号，困难

核心方法：动态规划，`dp[i]`表示以`s[i]`结尾的字符串中的最长有效括号数

难点：

+ base case：`dp[0] = 0`，只有一个括号肯定是不完整的

+ 当`s[i]=‘)’` 且 `s[i−1]=‘(’`，也就是字符串形如 “……()”，我们可以推出：`dp[i]=dp[i−2]+2`

+ `s[i]=‘)’` 且 `s[i−1]=‘)’`，也就是字符串形如 “……))”，我们可以推出：如果 `s[i−dp[i−1]−1]=‘(’`，那么 `dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2`。其中，`i−dp[i−1]−1`对应着“……))”中最后一个右括号的左括号，也就是这两个括号能够组成一对儿。在处理中，`dp[i−dp[i−1]−2]`表示<font color=red>去掉</font>所有当前i对应的右括号，及对应它的前面的左括号，和包含在这两个括号内的所有有效括号，<font color=red>之后的有效括号</font>，也就是往前走到当前右括号对应的左括号之前的位置。

  当然，如果往前走到当前右括号对应的左括号之前，就已经超出边界了，那么就不需要加上`dp[i−dp[i−1]−2]`这个数

+ 时间复杂度： O(n)
+ 空间复杂度： O(n)

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        dp = [0] * n
        if n == 0: return 0
        for i in range(1, len(s)):
            if s[i] == ')':
                if s[i-1] == '(':
                    dp[i] = dp[i-2] + 2
                elif i - dp[i-1] > 0 and s[i - dp[i-1] -1] == '(':
                    if i - dp[i-1] - 2 >= 0:
                        dp[i] = dp[i-1] + dp[i - dp[i-1] - 2] + 2
                    else:
                        dp[i] = dp[i-1] + 2
        return max(dp)
```



198，打家劫舍，中等

核心方法：动态规划，`dp[i]` 表示以`nums[i]`结尾的前i个房屋一共偷窃的最高金额

难点：

+ 只有一个房屋，那么`dp[0] = nums[0]`
+ 只有两个房屋，选择前两个房屋里钱多的那一个，那么`dp[1] = max(nums[0], nums[1])`
+ 对于第i个房屋要不要抢，如果抢前两个，那就是`dp[i-2] + nums[i]`；如果抢前一个，那么就是`dp[i-1]`
+ 所以选择大的那个，`dp[i] = max(dp[i-1], dp[i-2]+nums[i])`

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        # dp[i] 表示以nums[i]结尾的前i个房屋一共偷窃的最高金额
        if len(nums) < 2: return nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-2] + nums[i], dp[i-1])
        return dp[len(nums)-1]
```

改进方法：当前元素只和前两个结果有关，那么分别维护两个变量，分别记录上一次和这一次的结果

<font color=red>注意：更新 first 和 second 时，要写在一行，同时进行更新</font>

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) < 2: return nums[0]
        first = nums[0]
        second = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            first, second = second, max(first + nums[i], second)
        return second
```



213，打家劫舍2，中等

核心方法：头尾的两个房屋不能被同时打劫，要么选择[0..n-2]，要么选择[1..n-1]。构建内部函数，向函数中传递这两个范围的索引，然后将两个结果比较，选择较大的那个

时间复杂度：O(n)

空间复杂度：O(1)

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        def rob1(start, end):
            first = nums[start]
            second = max(nums[start], nums[start+1])
            for i in range(start+2, end+1):
                first, second = second, max(first+nums[i], second)
            return second

        if n == 1:
            return nums[0]
        elif n == 2:
            return max(nums[0], nums[1])
        else:
            return max(rob1(0, n-2), rob1(1, n-1))
```

