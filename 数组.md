# 笔记

## 35，搜索插入位置，简单

### 完成时间，3/20

### 核心方法：二分法

### 难点：二分窗口的边界情况，新边界如何产生

+ 变量定义：nums 数组，target 查找或插入的目标值

+ 搜索区间是否为空：
  + left = 0，right = len(nums)，此时查找区间为 [left, right] 闭区间，那么while中的终止条件应该是 left >= right，因为当 left == right 时，<font color=red>闭区间 [left, right] 不为空</font>，还可以取;
  + left = 0，right = len(nums) - 1，此时查找区间为 [left, right) 左闭右开区间，那么while中的终止条件应该是 left > right，因为当 left == right 时，<font color=red>左闭右开区间 [left, right) 不为空</font>，不能再取了;
+ 中间值的取法：
  + 为防止内存溢出的情况，中间下标为 mid = left + (right - left) // 2
+ nums[mid] 的值不等于 target 的情况：
  + 如果搜索区间是闭区间，当 nums[mid] > target, 或 nums[mid] < target 时，则分别对应 right = mid - 1 和 left = mid + 1。当要使用mid更新left，right时，由于是闭区间，终止条件中已经说明了mid和target下标的关系，也就是说left和right位置的值已经和target比较过了，应该move on了，所以left和right更新时应该考虑+1或者-1；跳出循环时，left指向target插入位置，返回left；
  + 如果搜索区间是左闭右开区间，当 nums[mid] > target, 或 nums[mid] < target 时，则分别对应 right = mid 和 left = mid + 1。当要使用mid更新left，right时，由于是左闭右开区间，并没有比较right位置的值和target谁大谁小，应该令right=mid，left不变；跳出循环时，left指向target插入位置，返回left

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        if len(nums) < 1: return 0
        left = 0
        right = len(nums) - 1  # 这里使用闭区间
        while(left <= right):  # left <= right 闭区间
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                right = mid - 1  # 闭区间
            else:
                left = mid + 1
        return right + 1
```



## 27，移除元素，简单

### 完成时间：3/21

### 核心方法：双指针

### 难点：需要考虑到字符覆盖

+ 题目输入的是一个数组和移除值，返回的是遍历完成后数组的长度（移除完成后的长度）
+ 因为字符在内存中以连续空间存储，如果移除值在数组中出现，则需要将后面的值往前移，覆盖这个值，不能直接删除
+ 使用快慢指针，两指针同时移动，
  + 当数组中遍历到的值等于移除值时，需要将快指针+1；
  + <font color=red>当数组中遍历到的值不等于移除值时，将快指针对应的值赋值给慢指针对应的值（这可以看作是连续赋值）</font>
+ 当快指针走到头时，说明一遍就遍历完了，那么慢指针所在的位置，即是遍历移除后这个数组的长度

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 使用快慢指针，可以在O(n)下完成循环
        slow, fast = 0, 0
        while (fast < len(nums)):
            if val != nums[fast]:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```



## 724，寻找数组的中心下标，简单

### 完成时间：3/27

### 难点：首先获取这个数组的元素之和Sum，然后遍历一遍这个数组，判断 <font color=red>nums[i] + sum(nums[:i]) * 2 是否等于 Sum </font>

```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        if len(nums) == 0: return -1
        s = sum(nums)
        for i in range(len(nums)):
            if sum(nums[:i])*2 + nums[i] == s:
                return i
        return -1
```



## 56，合并区间，中等

### 完成时间：3/27

### 核心方法：排序，对每个小区间内的左边界进行排序，然后判断每个区间的右边界是否在第二个区间的内部

+ 注意sort的排序用法
+ 每次更新的对象其实是上一个，也就是说每次遍历的对象是当前区间，根据当前区间的左边界是否大于上一个区间的右边界来判断
  + 如果小于，则两个区间有重合，更新上一个区间时，其左边界取【上一个右边界】和【当前区间右边界】的最大值
  + 如果大于，则两个区间没有重合，上一个区间就是独立区间（添加到结果中），将当前区间变为上一个区间
  + 最后别忘了，要把最后一个区间添加到结果中

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        # 首先是有序，判断区间内的第二个数是否在下一个区间内，如果在则可以合并；
        if len(intervals) < 2: return intervals
        intervals.sort(key=lambda x:x[0])  # 对左边区间进行排序
        last = intervals[0].copy()
        res = []
        for i in range(1, len(intervals)):
            if intervals[i][0] <= last[1]:
                # 包含重叠的情况
                last[1] = max(last[1], intervals[i][1])
            else:
                # 不包含重叠的情况
                res.append(last)
                last = intervals[i].copy()
        res.append(last)
        return res
```





## 15,  三数之和，中等

### 完成时间：3/31

### 核心方法：数组排序，使用双指针（当前值的右侧为左指针，右侧的右侧为右指针）

### 难点：左右指针的起始位置及移动方向，循环中的边界条件

+ 数组排序的目的是使得数组有序，并简化步骤。由于要求三数之和为0，根据左右指针的定义，如果当前值nums[i] > 0，后面的就不必计算了，一定和是大于0的。
+ 双指针的目的：1. 固定 i 的情况下遍历剩下的数组，2.避免重复计算。
  + <font color=red> 指定左指针为 i+1, 右指针为 n-1 </font>，只要满足 L < R 的条件，且三数之和为0，此时需要判断当前 nums[i] 是否等于下一个 nums[i]（L 往右遍历，R 向左遍历），如果是，则需要更新 L 和 R 的位置
  + 如果三数之和大于0，则说明 R 大了，更新 R 的位置
  + 如果三数之和小于0，则说明 L 小了，更新 L 的位置
  + 避免重复计算时，会比较 【i，i-1】，【L，L+1】，【R，R-1】的大小，此时需要给出边界条件，避免出现溢出的情况

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        if len(nums) <= 2 or not nums: return []
        res = []
        n = len(nums)
        nums.sort()
        for i in range(n):
            if nums[i] > 0:
                return res
            if (i > 0 and nums[i] == nums[i-1]):
                # 注意这种情况，排序过后先处理 i-1 位置的，然后才处理 i
                # 如果nums[i-1]和nums[i]相等，直接让 i-1 变为 i+1，即跳过i，下面对L和R的处理相同
                continue
            L = i + 1
            R = n - 1
            while(L < R):
                if nums[i] + nums[L] + nums[R] == 0:
                    res.append([nums[i], nums[L], nums[R]])
                    # while 条件 L<R 给出了一个边界，使得 L+1 没有超出边界
                    while(L<R and nums[L] == nums[L+1]):  
                        L += 1
                    while(L<R and nums[R] == nums[R-1]):
                        R -= 1
                    L += 1
                    R -= 1
                elif nums[i] + nums[L] + nums[R] > 0:
                    R -= 1
                else:
                    L += 1
        return res
```



## 53，最大子序和，简单

### 完成时间：3/31

### 核心方法：动态规划

### 难点： dp数组定义：dp[i] 为 数组 nums[:i] 的连续子数组最大和

+ 状态：随着新加入的一个数，连续数组的和为变量
+ 选择：新加入的数 nums[i] 与前面的和合并？还是自己作为一个新的序列

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 使用动态规划
        if len(nums) < 2: return nums[0]
        # 状态：（变量）子序和
        # 选择：当前元素（1）与前面的数组进行结合（2）自己开始一个新数组
        # 席间dp数组，定义dp[i] 表示前i个数组成的数组中的最大子序和
        dp = nums
        for i in range(1, len(nums)):
            dp[i] = max(dp[i-1] + nums[i], nums[i])
        return max(dp)
```



## 88，合并两个有序数组，简单

### 完成时间：4/1

### 核心方法：双指针，从后往前，不使用额外空间

+ 两个指针p1，p2分别从两数组的末尾开始遍历，p为nums1的空间末尾指针，比较p1，p2对应的值，谁大，谁就赋值给p对应的值，直到p1或p2小于0
+ 注意最后，p2需要将剩余没遍历的数替换掉nums1中没遍历的值
+ 复杂度分析：
  + 空间复杂度：O（1）
  + 时间复杂度：O（m+n）

```python
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: void Do not return anything, modify nums1 in-place instead.
        """
        # two get pointers for nums1 and nums2
        p1 = m - 1
        p2 = n - 1
        # set pointer for nums1
        p = m + n - 1
        
        # while there are still elements to compare
        while p1 >= 0 and p2 >= 0:
            if nums1[p1] < nums2[p2]:
                nums1[p] = nums2[p2]
                p2 -= 1
            else:
                nums1[p] =  nums1[p1]
                p1 -= 1
            p -= 1
        
        # add missing elements from nums2
        # 注意，这里的nums1括号内的指针是p2而不是p，因为如果走到这一步，p1已经结束了，并且p=p1+p2，所以剩下的就是将[:p2+1]全部赋值过去
        nums1[:p2 + 1] = nums2[:p2 + 1]
```



## 4，寻找两个正序数组的中位数，困难

### 完成时间：4/1

### 核心方法：第k小的数，使用二分法

### 难点：k的取值，以及每次去掉的数组的部分后k的更新

+ 复杂度分析：
  + 时间复杂度：O(log(m+n))
  + 空间复杂度：O(1)

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        def getKthElement(k):
            """
            - 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
            - 这里的 "/" 表示整除
            - nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
            - nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
            - 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
            - 这样 pivot 本身最大也只能是第 k-1 小的元素
            - 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部"删除"，剩下的作为新的 nums1 数组
            - 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部"删除"，剩下的作为新的 nums2 数组
            - 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
            - 注意：
            		- 如果 k = 1，则返回两数组中0位置(即第1小的数)小的那个数，就是中位数
            		- 如果一个指针走到头，就返回另一数组中第k小的数
            """
            # 这里的k就表示中位数的下标+1（因为k是根据m和n（数组长度）算出来的），
            # 设定两个指针都是指向两个不断更新的有序数组的头，即每个更新后的数组的0位置
            index1, index2 = 0, 0
            while True:
                # 特殊情况：如果一个数组的指针走到头了，那么就返回另一个数组的第k小的数
                if index1 == m:
                    # idx2 表示删除后的数组，该数组从头开始算的第 idx2+k 个数，-1表示这个数的下标
                    return nums2[index2 + k - 1]
                if index2 == n:
                    return nums1[index1 + k - 1]
                  
                if k == 1:
                    # 第1小的k对应的数就是中位数了，返回当前指针下，两个数组中较小的数
                    return min(nums1[index1], nums2[index2])

                # 正常情况，分别将指针定位到第k小的数的位置，生成新指针（注意这里的k//2）
                newIndex1 = min(index1 + k // 2 - 1, m - 1)
                newIndex2 = min(index2 + k // 2 - 1, n - 1)
                # 判断两个数组中新指针下的数的大小
                pivot1, pivot2 = nums1[newIndex1], nums2[newIndex2]
                if pivot1 <= pivot2:
                    # 更新k值，需要减去偏移量：newIndex1-index1+1，也就是 k//2
                    k -= newIndex1 - index1 + 1
                    # 更新指针位置，因为包括newIndex1在内的右边都不要了，所以要+1
                    index1 = newIndex1 + 1
                else:
                    k -= newIndex2 - index2 + 1
                    index2 = newIndex2 + 1
        
        m, n = len(nums1), len(nums2)
        totalLength = m + n
        # 当两个有序数组的长度确定时，他们组合起来的中位数的index也就确定了，
        # 向getKthElement传递的就是这个中位数
        if totalLength % 2 == 1:
            # 针对组合后数组长度为奇数
            return getKthElement((totalLength + 1) // 2)
        else:
            # 针对组合后数组长度为偶数
            return (getKthElement(totalLength // 2) + getKthElement(totalLength // 2 + 1)) / 2
```



## 42，接雨水，困难

### 完成时间：4/2

### 核心方法1 ：左右双指针，分别从两头进行遍历，并维护左右两个最大高度；首先判断两个指针谁大，谁小就处理谁，然后判断小的那个和其对应的最大高度谁大，指针对应值大，则更新高度，对应值小，则计算接雨水的大小并类型

+ 复杂度分析
  + 时间复杂度：O(n)
  + 空间复杂度：O(1)

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        """
        分别从左右两端开始遍历，思路如下：
        对于左边开始移动的指针，只要右指针数比当前数大，且当前数还比左侧的小，则当前数处形成凹陷；
        如果当前数没有左侧数小，就将左侧最大数更新为当前数。
        对于右边开始移动的指针亦然。
        """
        # 边界条件
        if not height: return 0
        n = len(height)

        left, right = 0, n - 1  # 分别位于输入数组的两端
        maxleft, maxright = height[0],height[n - 1]
        ans = 0

        while left <= right:
            if height[left] < height[right]:
                if height[left] >= maxleft:
                    maxleft = height[left]
                else:
                    ans += maxleft - height[left]
                left += 1
            else:
                if height[right] >= maxright:
                    maxright = height[right]
                else:
                    ans += maxright - height[right]
                right -= 1
        return ans
```

### 核心方法2: 使用单调递减栈，栈中存储数组索引。从左至右进行遍历，如果当前元素高度小于前一个元素高度，则当前索引入栈；否则，取出栈顶元素（在此处形成低洼），计算所接雨水的量，雨水的宽度是取出栈顶元素的宽度，高度是当前栈顶元素和当前遍历元素的最小高度

+ 复杂度分析：
  + 时间复杂度：O(n)
  + 空间复杂度：O(n) 栈

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        """
        使用一个递减栈来完成，遍历1次，时间复杂度为O（n），空间复杂度也是O（n）
        从左至右，如果当前元素的高度【小于等于】前一个元素高度，则进行压栈；
        如果当前元素的高度【大于】前一个元素，则栈顶处凹陷，左边为栈顶的前一个元素，右边为当前元素，可计算面积
        面积的宽度为 当前元素index - 前一元素index - 1，高度为左右两边低的那个
        """
        stack = []           
        res = 0  # 记录接雨水的量
        for i in range(len(height)):
            while stack and height[i] > height[stack[-1]]: 
                top = stack.pop()  # 出栈后，栈顶元素变为下面的一个
                if not stack: break  # 如果栈为空，说明左边没有柱子接雨水了
                width = (i - stack[-1] - 1)  # 两个下标的差再减1，表示雨水宽度
                lenght = min(height[i], height[stack[-1]]) - height[top]  # 取两个边界高度的最小值
                res += width * lenght
            stack.append(i)  # 栈内存储的是元素的下标
        return res
```



## 11, 盛最多水的容器，中等

### 完成时间：4/3

### 核心方法：首先应该想要在一次遍历内完成，一定要使用【双指针】

### 难点：结合上面【接雨水】的题目，可以知道，需要移动的指针，应该是对应数较小的那一个。

+ 双指针分别从数组的两头开始，移动指针意味着宽度要减小；如果移动对应大数的指针，则有可能水的面积会减小
+ 复杂度分析：
  + 时间复杂度：O(n)
  + 空间复杂度：O(1)

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 双指针法
        # 两个指针分别从两端进行遍历，每次遍历移动对应数较小的指针，因为小的数（即小的高度）决定了盛水的大小
        # 然后计算两指针的区间内的盛水面积，维护一个最大面积
        n = len(height)
        L = 0
        R = n - 1
        ans = 0
        while (L <= R):
            ans = max(ans, min(height[L], height[R]) * (R - L))
            if height[L] < height[R]:
                L += 1
            else:
                R -= 1
        return ans
```



