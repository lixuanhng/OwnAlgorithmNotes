# 笔记

### 链表排序

时间复杂度是 $O(nlogn)$ 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 $O(n^2)$，其中最适合链表的排序算法是归并排序。

归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 $O(\log n)$。如果要达到 $O(1)$ 的空间复杂度，则需要使用自底向上的实现方式。

如果使用指针法，需要在循环之前初始化指针的指向；<font color=red>特别注意：循环开始后，全部的操作都是围绕指针的，不能再操作节点了</font>

## 203，移除链表元素，简单

### 完成时间：4/6

### 核心方法：哨兵节点（作为伪头，伪尾）

+ 如果删除的是中间的节点，则直接将当前节点的前一节点的指针等于当前节点的指针；如果需要删除的节点是头节点，则使用哨兵节点，作为伪头

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        # 初始化哨兵节点
        sentinel = ListNode(0)
        sentinel.next = head
        # 初始化两个指针，分别指向前一个节点和当前节点
        prev, curr = sentinel, head
        while curr:
            # 当前指针不为空
            if curr.val == val:
                # 令当前节点的指针，等于前一个节点指针
                prev.next = curr.next
            else:
                # prev 向后移
                prev = curr
            # curr 向后移
            curr = curr.next
        # 返回 头节点
        return sentinel.next

```



## 707，设计链表，中等

### 完成时间：4/6

### 核心方法：使用哨兵节点

+ 这里的函数调用方法是一次调用的，首先一定会实例化 MyLinkedList，然后再使用这个类下的各种函数
+ size 应该是会根据每次调用时进行已有链表的长度计算

+ 单链表复杂度分析
  + 时间复杂度：
    addAtHead： O(1)
    addAtIndex，get，deleteAtIndex: O(k)，其中 kk 指的是元素的索引。
    addAtTail：O(N)，其中 N 指的是链表的元素个数。
  + 空间复杂度：所有的操作都是 O(1)

```python
# 单链表方法
class ListNode:
    def __init__(self, x):
      	# 自定义新节点，指定节点的值，指针为空
        self.val = x
        self.next = None

class MyLinkedList:
    def __init__(self):
      	# 初始化哨兵节点
        self.size = 0  # 始终存在一个伪头，所以这里的size=0
        self.head = ListNode(0)  # sentinel node as pseudo-head
        

    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        # if index is invalid
        if index < 0 or index >= self.size:
            return -1
        # 指定头节点
        curr = self.head
        # index steps needed 
        # to move from sentinel node to wanted index
        for _ in range(index + 1):
            curr = curr.next
        return curr.val  # 返回这个节点的值
            

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self.addAtIndex(0, val)  # 直接调用 addAtIndex
        

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self.addAtIndex(self.size, val)  # 直接调用 addAtIndex，新添加的节点index=self.size
        

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        # If index is greater than the length, 
        # the node will not be inserted.
        if index > self.size:
            return
        
        # [so weird] If index is negative, 
        # the node will be inserted at the head of the list.
        if index < 0:
            index = 0
        
        # 或许也可以理解为 要新增一个节点，这时其列表长度+1
        # 记录size变化的目的是为了比较index与size的大小，所以不能省略
        self.size += 1
        # find predecessor of the node to be added
        pred = self.head
        for _ in range(index):
            pred = pred.next
            
        # node to be added（生成新的节点）
        to_add = ListNode(val)
        # 进行插入操作
        to_add.next = pred.next
        pred.next = to_add
        

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        # if the index is invalid, do nothing
        if index < 0 or index >= self.size:
            return
        
        # 要删除一个节点，其列表长度-1
        self.size -= 1
        # find predecessor of the node to be deleted
        pred = self.head
        for _ in range(index):
            pred = pred.next
            
        # delete pred.next 
        pred.next = pred.next.next
```

+ 双链表方法复杂度分析：
  + 时间复杂度
    + `addAtHead`，`addAtTail`： O(1)
    + `get`，`addAtIndex`，`delete`：O(min(*k*,*N*−*k*))，其中 *k* 指的是元素的索引。
  + 空间复杂度：
    + 所有的操作都是 O(1)

```python
# 双链表方法
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next, self.prev = None, None  # 每个节点有两个指针

class MyLinkedList:
    def __init__(self):
        self.size = 0
        # sentinel nodes as pseudo-head and pseudo-tail，伪头，伪尾节点互相连接
        self.head, self.tail = ListNode(0), ListNode(0) 
        self.head.next = self.tail
        self.tail.prev = self.head
        

    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        # if index is invalid
        if index < 0 or index >= self.size:
            return -1
        
        # choose the fastest way: to move from the head
        # or to move from the tail
        if index + 1 < self.size - index:
            curr = self.head
            for _ in range(index + 1):
                curr = curr.next
        else:
            curr = self.tail
            for _ in range(self.size - index):
                curr = curr.prev
        return curr.val
            

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        # 相比于单链表，这里选择直接操作伪头，以及伪头的下一个
        # 将新节点插入到他们之间
        pred, succ = self.head, self.head.next
        
        self.size += 1
        to_add = ListNode(val)
        to_add.prev = pred
        to_add.next = succ
        pred.next = to_add
        succ.prev = to_add
        

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        # 相比于单链表，这里选择直接操作伪尾，以及伪尾的上一个
        # 将新节点插入到他们之间
        succ, pred = self.tail, self.tail.prev
        
        self.size += 1
        to_add = ListNode(val)
        to_add.prev = pred
        to_add.next = succ
        pred.next = to_add
        succ.prev = to_add
        

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        # If index is greater than the length, 
        # the node will not be inserted.
        if index > self.size:
            return
        
        # [so weird] If index is negative, 
        # the node will be inserted at the head of the list.
        if index < 0:
            index = 0
        
        # find predecessor and successor of the node to be added
        # 依旧判断从哪个方向加更快
        if index < self.size - index:
            pred = self.head
            for _ in range(index):
                pred = pred.next
            succ = pred.next
        else:
            succ = self.tail
            for _ in range(self.size - index):
                succ = succ.prev
            pred = succ.prev
        
        # insertion itself
        self.size += 1
        to_add = ListNode(val)
        to_add.prev = pred
        to_add.next = succ
        pred.next = to_add
        succ.prev = to_add
        

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        # if the index is invalid, do nothing
        if index < 0 or index >= self.size:
            return
        
        # find predecessor and successor of the node to be deleted
        # 还是判断从哪里开始
        if index < self.size - index:
            pred = self.head
            for _ in range(index):
                pred = pred.next
            succ = pred.next.next
        else:
            succ = self.tail
            for _ in range(self.size - index - 1):
                succ = succ.prev
            pred = succ.prev.prev
            
        # delete pred.next 
        self.size -= 1
        pred.next = succ
        succ.prev = pred
```



## 206，反转链表，简单

### 完成时间：4/6

### 核心方法：不需要开辟额外的空间，只需要更改每个节点指针指向的对象就行

+ 迭代法
+ 难点：注意需要在头节点前定义一个空头，pre = None
+ 复杂度分析
  - 遍历一次链表，时间复杂度为`O(n)`
  - 三个指针，空间复杂度为`O(1)`

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 首先定义一个指针，指向头节点
        # 这里不存在头节点的前面添加节点，所有不需要定义伪头
        cur = head
        pre = None  # 别忘了在头节点前定义一个空投
        while (cur != None):
            tmp = cur.next  # 当前节点的下一节点赋给tmp
            cur.next = pre  # 当前节点连接到上一个更新好的节点
            pre = cur  # 移动pre指针到新连接好的节点上
            cur = tmp  # 移动cur指针到待处理的下一个节点上
        return pre  # 当 cur 指向 None 时，pre指针已经指向了反转后链表的头节点处
```

+ 递归法
+ 复杂度分析
  + 链表仅被遍历一遍，时间复杂度为`O(n)`
  + 一共递归n次，需要数量为n的栈空间，空间复杂度为`O(n)`

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        # 当前函数的作用是：翻转当前链表，返回新的头指针
        # 递归反转head-next后的链表
        # 此时head.next就是反转后的尾部
        # 将head添加到尾部之后，即head.next.next = head
        # 并将head.next置为None
        if not head or not head.next:  # 遇到 none 停止迭代
            return head
        p = self.reverseList(head.next)  # p 是 head.next的下一个节点，即 head.next.next = p
        head.next.next = head  # 完成反转 即 3 -> 4 转为 4 -> 3
        head.next = None  # 即 4 -> 3 -> none
        return p  # p 是从后往前的每一个节点
```



## 104，环形链表，中等

### 完成时间：4/7

### 核心方法：

+ 双指针，fast一次走两点，slow一次走一点，当fast和slow相遇时即为相遇点
+ 然后设置fast一次走一点，另设置一个指针从头节点处一次走一点，当二者相遇时即为环的入口

### 难点：注意给定的链表不是环的情况

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast = head
        slow = head
        while True:
         		# 如果没有环，那么fast或是fast.next就为空，直接返回
            if not (fast and fast.next): return
            fast, slow = fast.next.next, slow.next
            if slow == fast: break  # 一旦二者相等，则推出循环
        fast = head
        while (slow != fast):
            slow = slow.next
            fast = fast.next
        return fast
```



## 21， 合并两个有序链表，简单

### 完成时间：4/7

### 核心方法：迭代，创建一个新的链表，而不是在原链表上进行更新

### 难点：设置伪头，然后比较两个链表指针对应节点谁小，小的接在新链表后面，然后对应指针后移一位

+ 分析复杂度：
  + 时间复杂度：O(m+n)
  + 空间复杂度：O(1)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeTwoLists(self, l1, l2):
        # 定义伪头节点，并指定当前指针从头节点开始
        prehead = ListNode(-1)  # 这个节点的值其实是随机指定的
        prev = prehead
        # 只要l1和l2不为空，就把小的那个作为伪头的下一个，且自身链表后移一位
        while l1 and l2:
            if l1.val <= l2.val:
                prev.next = l1
                l1 = l1.next
            else:
                prev.next = l2
                l2 = l2.next            
            prev = prev.next

        # 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev.next = l1 if l1 is not None else l2

        return prehead.next
```

### 核心方法：递归，递归调用 `mergeTwoLists` 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。

### 难点：两个链表头部值较小的一个节点与剩下元素的 `merge` 操作结果合并。

+ 复杂度分析：
  + 空间复杂度：O(m+n)
  + 时间复杂度：O(m+n)
+ 逻辑如下

```math
if list1[0] < list2[0]:
		list1[0] + merge(list1[1:], list2)
else:
		list2[0] + merge(list1, list2[1:])
```

```python
class Solution:
    def mergeTwoLists(self, l1, l2):
      	# 遇到空链表，则返回另一个链表
        if l1 is None:
            return l2
        elif l2 is None:
            return l1
        # 我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。
        # 实际的递归过程是由大到小返回节点
        elif l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

​	

## 143，重排链表，中等

### 完成时间：4/7

### 核心方法：这种插入方法，应当使用线性表（元素是节点的列表），这样就能通过下标访问链表节点了

### 难点：注意移动指针和两个指针相等的时候

+ 复杂度分析：
  + 时间复杂度：O(n)
  + 空间复杂度：O(n)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        # 使用线性表
        if not head: return 
        # 将所有节点一次加入列表中
        nodes = list()
        node = head
        while(node):
            nodes.append(node)
            node = node.next
        # 初始化指针位置
        i, j = 0, len(nodes)-1
        while (i < j):
            nodes[i].next = nodes[j]
            i += 1
            # 这一步加在这里是为了至少要完成一次相加
            if i == j: break
            nodes[j].next = nodes[i]
            j -= 1
        # 最后一个节点的指针要指向空
        nodes[i].next = None
```

### 核心方法：

+ 首先查找链表的中心位置（快慢指针）
+ 对中心位置的后半部分进行反转链表（迭代法）
+ 合并链表（注意节点指针重制指向后再移动指针）
+ 复杂度分析：
  + 时间复杂度：O(n)
  + 空间复杂度：O(1)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head: return

        mid = self.findMid(head)
        l1 = head
        l2 = mid.next
        mid.next = None  # 注意：这一步不能忘，有了这一步才能将链表分隔开
        l2_r = self.reverseListNode(l2)
        self.merge(l1, l2_r)

    def findMid(self, head):
        """找到链表的中心节点，快慢指针法"""
        fast = head
        slow = head
        while (fast and fast.next):
            fast = fast.next.next
            slow = slow.next
        return slow

    def reverseListNode(self, head):
        """迭代法，反转链表"""
        cur = head
        pre = None
        while (cur):
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre
        
    def merge(self, l1, l2_r):
      	"""链表合并"""
        while(l1 and l2_r):
            l1_tmp = l1.next
            l2_tmp = l2_r.next
						# 注意：节点指针完成重新指向后，再移动指针
            l1.next = l2_r
            l1 = l1_tmp
            # 注意：节点指针完成重新指向后，再移动指针
            l2_r.next = l1
            l2_r = l2_tmp
```



## 19，删除链表的倒数第N个节点，中等

### 完成时间：4/8

### 核心方法：快指针比慢指针多走n步，然后快慢指针同时走直到头，慢指针所在的位置就是要删除的节点

### 难点：

+ 如果要删除某一节点，必须确定上一个节点，所以要在代码中加入上一个节点的指针
+ 如果链表长度就等于1，且n=1，那么就回删除第一个，所以这里需要加入伪头节点指向head
+ 这样的话，可以一开始就指定【上一节点】的初始值为伪头，在slow，fast同时行走时再令【上一节点】等于slow节点
+ 复杂度分析：
  + 时间复杂度：O(链表长度)
  + 空间复杂度：O(1)
+ 当然，slow也可以从伪头开始，fast走到头时，slow.next 才是需要删除的节点，可直接令 slow.next = slow.next.next

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        # 因为有可能要把第一个删掉，所以需要添加一个伪头
        sental = ListNode(-1)
        sental.next = head
        
        fast = head
        slow = head
        while (n > 0):
            fast = fast.next
            n -= 1
            
        prev = sental
        while (fast != None):
            fast = fast.next
            prev = slow
            slow = slow.next
            
        tmp = slow.next
        prev.next = tmp
        return sental.next
```



## 148，排序链表，中等

### 完成时间：4/8

### 核心方法：归并排序（递归调用），分治，快慢指针

### 难点：使用分治法，找到链表的中点，一分为二；递归内部：分别对两个链表进行升序排序，然后合并两个有序链表

+ 复杂度分析：
  + 时间复杂度：O(nlogn)
  + 空间复杂度：O(logn)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间。

```python
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        def sortFunc(head: ListNode, tail: ListNode) -> ListNode:
            if not head: return head  # 链表为空，直接返回这个链表
            # 这里要判断是否到了二分链表的尾部，如果到达，则将最后一个节点指向none，表示断开或完结
            if head.next == tail: 
                head.next = None
                return head
           	# 使用快慢指针，fast比slow快一步
            slow = fast = head
            while fast != tail:
                slow = slow.next
                fast = fast.next
                # 这里要确保fast不能指向空
                if fast != tail: 
                    fast = fast.next
            mid = slow
            return merge(sortFunc(head, mid), sortFunc(mid, tail))
            
        def merge(head1: ListNode, head2: ListNode) -> ListNode:
            dummyHead = ListNode(0)  # 设置伪头
            temp, temp1, temp2 = dummyHead, head1, head2
            while temp1 and temp2:
                # 谁小，就连接谁，谁的指针就后移一位
                if temp1.val <= temp2.val:
                    temp.next = temp1
                    temp1 = temp1.next
                else:
                    temp.next = temp2
                    temp2 = temp2.next
                # 当前的temp已经更新了，需要后移一位
                temp = temp.next
            # 把剩余的那个链表接在temp后面
            if temp1:
                temp.next = temp1
            elif temp2:
                temp.next = temp2
            return dummyHead.next
        
        return sortFunc(head, None)
```







