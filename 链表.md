# 笔记

## 203，移除链表元素，简单

### 完成时间：4/6

### 核心方法：哨兵节点（作为伪头，伪尾）

+ 如果删除的是中间的节点，则直接将当前节点的前一节点的指针等于当前节点的指针；如果需要删除的节点是头节点，则使用哨兵节点，作为伪头

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        # 初始化哨兵节点
        sentinel = ListNode(0)
        sentinel.next = head
        # 初始化两个指针，分别指向前一个节点和当前节点
        prev, curr = sentinel, head
        while curr:
            # 当前指针不为空
            if curr.val == val:
                # 令当前节点的指针，等于前一个节点指针
                prev.next = curr.next
            else:
                # prev 向后移
                prev = curr
            # curr 向后移
            curr = curr.next
        # 返回 头节点
        return sentinel.next

```



## 707，设计链表，中等

### 完成时间：4/6

### 核心方法：使用哨兵节点

+ 这里的函数调用方法是一次调用的，首先一定会实例化 MyLinkedList，然后再使用这个类下的各种函数
+ size 应该是会根据每次调用时进行已有链表的长度计算

+ 单链表复杂度分析
  + 时间复杂度：
    addAtHead： O(1)
    addAtIndex，get，deleteAtIndex: O(k)，其中 kk 指的是元素的索引。
    addAtTail：O(N)，其中 N 指的是链表的元素个数。
  + 空间复杂度：所有的操作都是 O(1)

```python
# 单链表方法
class ListNode:
    def __init__(self, x):
      	# 自定义新节点，指定节点的值，指针为空
        self.val = x
        self.next = None

class MyLinkedList:
    def __init__(self):
      	# 初始化哨兵节点
        self.size = 0  # 始终存在一个伪头，所以这里的size=0
        self.head = ListNode(0)  # sentinel node as pseudo-head
        

    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        # if index is invalid
        if index < 0 or index >= self.size:
            return -1
        # 指定头节点
        curr = self.head
        # index steps needed 
        # to move from sentinel node to wanted index
        for _ in range(index + 1):
            curr = curr.next
        return curr.val  # 返回这个节点的值
            

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self.addAtIndex(0, val)  # 直接调用 addAtIndex
        

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self.addAtIndex(self.size, val)  # 直接调用 addAtIndex，新添加的节点index=self.size
        

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        # If index is greater than the length, 
        # the node will not be inserted.
        if index > self.size:
            return
        
        # [so weird] If index is negative, 
        # the node will be inserted at the head of the list.
        if index < 0:
            index = 0
        
        # 或许也可以理解为 要新增一个节点，这时其列表长度+1
        # 记录size变化的目的是为了比较index与size的大小，所以不能省略
        self.size += 1
        # find predecessor of the node to be added
        pred = self.head
        for _ in range(index):
            pred = pred.next
            
        # node to be added（生成新的节点）
        to_add = ListNode(val)
        # 进行插入操作
        to_add.next = pred.next
        pred.next = to_add
        

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        # if the index is invalid, do nothing
        if index < 0 or index >= self.size:
            return
        
        # 要删除一个节点，其列表长度-1
        self.size -= 1
        # find predecessor of the node to be deleted
        pred = self.head
        for _ in range(index):
            pred = pred.next
            
        # delete pred.next 
        pred.next = pred.next.next
```

+ 双链表方法复杂度分析：
  + 时间复杂度
    + `addAtHead`，`addAtTail`： O(1)
    + `get`，`addAtIndex`，`delete`：O(min(*k*,*N*−*k*))，其中 *k* 指的是元素的索引。
  + 空间复杂度：
    + 所有的操作都是 O(1)

```python
# 双链表方法
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next, self.prev = None, None  # 每个节点有两个指针

class MyLinkedList:
    def __init__(self):
        self.size = 0
        # sentinel nodes as pseudo-head and pseudo-tail，伪头，伪尾节点互相连接
        self.head, self.tail = ListNode(0), ListNode(0) 
        self.head.next = self.tail
        self.tail.prev = self.head
        

    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        # if index is invalid
        if index < 0 or index >= self.size:
            return -1
        
        # choose the fastest way: to move from the head
        # or to move from the tail
        if index + 1 < self.size - index:
            curr = self.head
            for _ in range(index + 1):
                curr = curr.next
        else:
            curr = self.tail
            for _ in range(self.size - index):
                curr = curr.prev
        return curr.val
            

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        # 相比于单链表，这里选择直接操作伪头，以及伪头的下一个
        # 将新节点插入到他们之间
        pred, succ = self.head, self.head.next
        
        self.size += 1
        to_add = ListNode(val)
        to_add.prev = pred
        to_add.next = succ
        pred.next = to_add
        succ.prev = to_add
        

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        # 相比于单链表，这里选择直接操作伪尾，以及伪尾的上一个
        # 将新节点插入到他们之间
        succ, pred = self.tail, self.tail.prev
        
        self.size += 1
        to_add = ListNode(val)
        to_add.prev = pred
        to_add.next = succ
        pred.next = to_add
        succ.prev = to_add
        

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        # If index is greater than the length, 
        # the node will not be inserted.
        if index > self.size:
            return
        
        # [so weird] If index is negative, 
        # the node will be inserted at the head of the list.
        if index < 0:
            index = 0
        
        # find predecessor and successor of the node to be added
        # 依旧判断从哪个方向加更快
        if index < self.size - index:
            pred = self.head
            for _ in range(index):
                pred = pred.next
            succ = pred.next
        else:
            succ = self.tail
            for _ in range(self.size - index):
                succ = succ.prev
            pred = succ.prev
        
        # insertion itself
        self.size += 1
        to_add = ListNode(val)
        to_add.prev = pred
        to_add.next = succ
        pred.next = to_add
        succ.prev = to_add
        

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        # if the index is invalid, do nothing
        if index < 0 or index >= self.size:
            return
        
        # find predecessor and successor of the node to be deleted
        # 还是判断从哪里开始
        if index < self.size - index:
            pred = self.head
            for _ in range(index):
                pred = pred.next
            succ = pred.next.next
        else:
            succ = self.tail
            for _ in range(self.size - index - 1):
                succ = succ.prev
            pred = succ.prev.prev
            
        # delete pred.next 
        self.size -= 1
        pred.next = succ
        succ.prev = pred
```



## 206，反转链表，简单

### 完成时间：4/6

### 核心方法：不需要开辟额外的空间，只需要更改每个节点指针指向的对象就行

+ 迭代法
+ 复杂度分析
  - 遍历一次链表，时间复杂度为`O(n)`
  - 三个指针，空间复杂度为`O(1)`

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 首先定义一个指针，指向头节点
        cur = head
        pre = None
        while (cur != None):
            tmp = cur.next  # 当前节点的下一节点赋给tmp
            cur.next = pre  # 当前节点连接到上一个更新好的节点
            pre = cur  # 移动pre指针到新连接好的节点上
            cur = tmp  # 移动cur指针到待处理的下一个节点上
        return pre  # 当 cur 指向 None 时，pre指针已经指向了反转后链表的头节点处
```

+ 递归法
+ 复杂度分析
  + 链表仅被遍历一遍，时间复杂度为`O(n)`
  + 一共递归n次，需要数量为n的栈空间，空间复杂度为`O(n)`

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        # 当前函数的作用是：翻转当前链表，返回新的头指针
        # 递归反转head-next后的链表
        # 此时head.next就是反转后的尾部
        # 将head添加到尾部之后，即head.next.next = head
        # 并将head.next置为None
        if not head or not head.next:  # 遇到 none 停止迭代
            return head
        p = self.reverseList(head.next)  # p 是 head.next的下一个节点，即 head.next.next = p
        head.next.next = head  # 完成反转 即 3 -> 4 转为 4 -> 3
        head.next = None  # 即 4 -> 3 -> none
        return p  # p 是从后往前的每一个节点
```



## 104，环形链表，中等

### 完成时间：4/7

### 核心方法：

+ 双指针，fast一次走两点，slow一次走一点，当fast和slow相遇时即为相遇点
+ 然后设置fast一次走一点，另设置一个指针从头节点处一次走一点，当二者相遇时即为环的入口

### 难点：注意给定的链表不是环的情况

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast = head
        slow = head
        while True:
         		# 如果没有环，那么fast或是fast.next就为空，直接返回
            if not (fast and fast.next): return
            fast, slow = fast.next.next, slow.next
            if slow == fast: break  # 一旦二者相等，则推出循环
        fast = head
        while (slow != fast):
            slow = slow.next
            fast = fast.next
        return fast
```



## 21， 合并两个有序链表，简单

### 核心方法：迭代，创建一个新的链表，而不是在原链表上进行更新

### 难点：设置伪头，然后比较两个链表指针对应节点谁小，小的接在新链表后面，然后对应指针后移一位

+ 分析复杂度：
  + 时间复杂度：O(m+n)
  + 空间复杂度：O(1)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeTwoLists(self, l1, l2):
        # 定义伪头节点，并指定当前指针从头节点开始
        prehead = ListNode(-1)  # 这个节点的值其实是随机指定的
        prev = prehead
        # 只要l1和l2不为空，就把小的那个作为伪头的下一个，且自身链表后移一位
        while l1 and l2:
            if l1.val <= l2.val:
                prev.next = l1
                l1 = l1.next
            else:
                prev.next = l2
                l2 = l2.next            
            prev = prev.next

        # 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev.next = l1 if l1 is not None else l2

        return prehead.next
```

### 核心方法：递归，递归调用 `mergeTwoLists` 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。

### 难点：两个链表头部值较小的一个节点与剩下元素的 `merge` 操作结果合并。

+ 复杂度分析：
  + 空间复杂度：O(m+n)
  + 时间复杂度：O(m+n)
+ 逻辑如下

```math
if list1[0] < list2[0]:
		list1[0] + merge(list1[1:], list2)
else:
		list2[0] + merge(list1, list2[1:])
```

```python
class Solution:
    def mergeTwoLists(self, l1, l2):
      	# 遇到空链表，则返回另一个链表
        if l1 is None:
            return l2
        elif l2 is None:
            return l1
        # 我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。
        # 实际的递归过程是由大到小返回节点
        elif l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

​	







