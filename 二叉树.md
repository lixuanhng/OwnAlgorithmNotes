二叉树相关



105，从前序与中序遍序列构造二叉树，中等

核心方法：递归

对于任意一棵树而言，前序遍历的结果总是：`[根结点，[左子树的前序结果]，[右子树的前序结果]]`

后序遍历的结果总是：`[[左子树的前序结果]，根结点，[右子树的前序结果]]`

只要在中序遍历中确定了根结点的位置，那么就可以知道左右子树的节点个数，这样就可以在前序遍历的结果中对左右括号进行定位。最后通过找到的左子树（右子树）的前序结果和中序结果，然后递归调用。

可以采用哈希映射将中序遍历中各个节点值对应的序号取出来，这样能够在O(1)复杂度内查到根结点的位置。

- 时间复杂度：O(n)，其中 n 是树中的节点个数。
- 空间复杂度：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h<n，所以总空间复杂度为 O(n)。


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        def myBuildTree(pre_left, pre_right, in_left, in_right):
            if pre_left > pre_right:
                return None
            pre_root_index = pre_left  # 前序遍历中根结点的位置，也就是第一个
            in_root_index = index[preorder[pre_root_index]]  # 中序遍历结果中的根节点

            # 把当前根节点建立出来
            root = TreeNode(preorder[pre_root_index])
            # 左子树的节点数目
            left_subtree_size = in_root_index - in_left

            # 构造左子树
            root.left = myBuildTree(pre_left+1, pre_left+left_subtree_size, in_left, in_root_index-1)
            # 构造右子树
            root.right = myBuildTree(pre_left+left_subtree_size+1, pre_right, in_root_index+1, in_right)
            return root
        
        n = len(preorder)
        index = {element: i for i, element in enumerate(inorder)}
        return myBuildTree(0 ,n-1, 0, n-1)
```



101，对称二叉树，简单

核心方法：递归。注意三个终止条件

+ 时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。

+ 空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root: return True
        def next(l, r):
            # 结束条件
            if not l and not r:
                # 左右节点都为空
                return True
            if not l or not r:
                # 左右节点有一个为空
                return False
            if l.val != r.val:
                # 左右节点值不想等
                return False
            return next(l.left, r.right) and next(l.right, r.left)
        return next(root.left, root.right)
```

核心方法：迭代，使用队列。如果当前节点满足条件，就将下面待比较的每组添加到队列中，直到队列为空

+ 时间复杂度：O(n)

+ 空间复杂度：O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        # 使用队列
        if not root: return True
        q = [(root.left, root.right)]
        
        while q:
            left, right = q.pop()
            if not left and not right:
                continue
            
            if left and right and left.val == right.val:
                q.append((left.left, right.right))
                q.append((left.right, right.left))
            else:
                return False
        return True
```



98，验证二叉搜索树，中等

核心方法：递归，在向下探索的过程中，不断检查左子节点，右子节点和根结点的关系是否满足条件；只要不满足条件，直接return False

时间复杂度：O(n)

空间复杂度：O(n)，树高最高为n

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        if not root: 
            return True

        def search(node, min_v, max_v):
            if not node: 
                return True

            if node.left:
                if node.left.val >= node.val or node.left.val <= min_v:
                    return False

            if node.right:
                if node.right.val <= node.val or node.right.val >= max_v:
                    return False

            return search(node.left, min_v, node.val) and search(node.right, node.val, max_v)
        
        return search(root, -2**32, 2**32)
```

根据搜索二叉树的性质，中序遍历得到的结果一定是升序的。那么通过迭代的方法，中序遍历这个树，分别记录每个节点的值，然后判断当前遍历到的值是否大于上一个值，如果不大于，则return False，全遍历完后return True。使用栈来维护每个根结点。

```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack, inorder = list(), float('-inf')
        
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            if root.val <= inorder:
                return False
            inorder = root.val
            root = root.right
            
        return True
```



226，翻转二叉树，简单

核心方法：向下进行递归，分别取当前节点的左子节点和右子节点，然后分别将他们赋值给当前节点的右子树和左子树

时间复杂度：O(N)，每个节点遍历一遍，在常数空间内交换两颗树

空间复杂度：O(N)，使用的空间由递归栈的深度决定。最坏情况下，树形成链状，空间复杂度为O(N)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left, root.right = right, left
        return root
```



543，二叉树的直径，简单

核心方法：向下递归，找到每个节点的左最大深度和右最大深度，+1得到当前节点下的最多节点路径。比较每个节点的最多节点路径并维护。遍历完成后，最长直径等于最多节点路径上的最长直径，也就是节点数-1

时间复杂度：O(N)

空间复杂度：O(N)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        # 维护一个变量记录每次递归完成后的路径经的所有节点数
        self.ans = 1
        def depth(node):
            if not node: return 0
            # 先找到每个根节点的左子树节点
            L = depth(node.left)
            # 再找到每个根节点的右子树节点
            R = depth(node.right)
            # 更新最多的节点数，加1表示计算了当前节点
            self.ans = max(self.ans, L+R+1)
            # 返回（左或右）最大深度，加1表示计算了当前节点
            return max(L, R) + 1

        depth(root)
        # 最长直径等于路径上最多节点数-1
        return self.ans - 1
```



110，平衡二叉树，简单

核心方法：从根节点开始，向下递归，检查左右子树是否是平衡的。递归返回的是从当前节点开始的最大深度（不忘记算上当前节点，要+1）。在递归的过程中，只要遇到某节点的左右子树有一个等于-1，即深度差大于1，就一直向上返回-1，在最顶端判断为False；否则判断为True

时间复杂度：O(N)

空间复杂度：O(N)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def recur(root):
            if not root:
                return 0
            
            left = recur(root.left)
            if left == -1: 
                return -1
            
            right = recur(root.right)
            if right == -1: 
                return -1
            return max(left, right) + 1 if abs(left- right) < 2 else -1
        
        return recur(root) != -1
```



剑指offer32，从上到下打印二叉树，中等

核心方法：二叉树的层级遍历，使用队列。将每个节点放进队列。从队列中取出一个节点，将其值保存，将其左右节点加入队列。

时间复杂度：O(N)

空间复杂度：O(N)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[int]:
        if not root: return []
        queue = [root]
        res = list()
        while queue:
            node = queue.pop(0)
            res.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        return res
```



297，二叉树的序列化与反序列化，困难

核心方法：

+ 序列化的方法使用层级遍历的方式，要注意的是如果遍历的节点为空，那么需要向结果列表中添加 ‘None’。返回时需要注意将结果列表变为字符串
+ 反序列化的方法，首先将第一个值进行节点化，将当前节点放入双端队列。只要队列不为空，就弹出一个节点，按顺序取序列化列表中两个值，只要不为空，就分别将他们设置为节点然后接在当前节点下，成为左子节点和右子节点。最后返回root节点就行。
+ 时间复杂度：O(N)
+ 空间复杂度：O(N)

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root: return ''
        queue = [root]
        res = list()
        while queue:
            node = queue.pop(0)
            if node:
                res.append(str(node.val))
                queue.append(node.left) 
                queue.append(node.right)
            else:
                res.append('None')
        return '[' + ','.join(res) + ']'
        

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data: return []
        datalist = data[1:-1].split(',')
        root = TreeNode(int(datalist[0]))
        queue = collections.deque([root])
        i = 1
        while queue:
            node = queue.popleft()
            if datalist[i] != 'None':
                node.left = TreeNode(int(datalist[i]))
                queue.append(node.left)
            i += 1
            
            if datalist[i] != 'None':
                node.right = TreeNode(int(datalist[i]))
                queue.append(node.right)
            i += 1
        return root

        

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
```



236，二叉树的最近公共祖先，简单

核心方法：向下递归，如果当前节点为空，或者等于p或q中的一个，说明到头了；或是找到了p或q，此时返回当前节点。查看返回的左右节点，如果一个为空，那么就返回另一个。

也就是说，当向下递归找到p和q时，向上传递的就是p和q，或者为空。当遇到p和q的最近公共祖先时，返回的就是当前节点，也就是最近公共祖先，对应于函数最下面的 `return root`

+ 时间复杂度：O(N)
+ 空间复杂度：O(N)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if not left: return right
        if not right: return left
        return root
```



671，二叉树中第二小的节点，简单

核心方法：递归+排序

使用哈希集合记录树中所有的唯一值，即使多个节点有相同值，值的唯一性会在集合中保证。递归完成后，将集合结果转化为列表，然后对其排序

+ 时间复杂度：递归为O(n)，排序复杂度为O(nlogn)，最大为O(nlogn)
+ 空间复杂度：在于哈希集合，最坏情况下为O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        def dfs(node):
            if not node:
                return 
            vals.add(node.val)
            dfs(node.left)
            dfs(node.right)
        
        if not root: return -1
        vals = set()
        dfs(root)
        if len(vals) < 2:
            return -1
        res = list(vals)
        res.sort()
        return res[1]
```

只使用递归，如果当前节点不等于（根据这种树的性质，那就一定是大于）根节点的值，则比较（当前节点，递归左节点，递归右节点），找到最小值；反之则递归左右子节点，找最小值（不等于根节点的值）

时间复杂度： O(n)

空间复杂度： O(n)

```python
class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        judge = root.val
        def find(root):
            if not root:
                return 1000000000000
            if root.val == judge:
                return min(find(root.left),find(root.right))
            return min(root.val,find(root.left),find(root.right))
        second = find(root)
        return second if second !=1000000000000 else -1
```

