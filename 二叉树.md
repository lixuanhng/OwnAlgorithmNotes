二叉树相关



105，从前序与中序遍序列构造二叉树，中等

核心方法：递归

对于任意一棵树而言，前序遍历的结果总是：`[根结点，[左子树的前序结果]，[右子树的前序结果]]`

后序遍历的结果总是：`[[左子树的前序结果]，根结点，[右子树的前序结果]]`

只要在中序遍历中确定了根结点的位置，那么就可以知道左右子树的节点个数，这样就可以在前序遍历的结果中对左右括号进行定位。最后通过找到的左子树（右子树）的前序结果和中序结果，然后递归调用。

可以采用哈希映射将中序遍历中各个节点值对应的序号取出来，这样能够在O(1)复杂度内查到根结点的位置。

- 时间复杂度：O(n)，其中 n 是树中的节点个数。
- 空间复杂度：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h<n，所以总空间复杂度为 O(n)。


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        def myBuildTree(pre_left, pre_right, in_left, in_right):
            if pre_left > pre_right:
                return None
            pre_root_index = pre_left  # 前序遍历中根结点的位置，也就是第一个
            in_root_index = index[preorder[pre_root_index]]  # 中序遍历结果中的根节点

            # 把当前根节点建立出来
            root = TreeNode(preorder[pre_root_index])
            # 左子树的节点数目
            left_subtree_size = in_root_index - in_left

            # 构造左子树
            root.left = myBuildTree(pre_left+1, pre_left+left_subtree_size, in_left, in_root_index-1)
            # 构造右子树
            root.right = myBuildTree(pre_left+left_subtree_size+1, pre_right, in_root_index+1, in_right)
            return root
        
        n = len(preorder)
        index = {element: i for i, element in enumerate(inorder)}
        return myBuildTree(0 ,n-1, 0, n-1)
```



101，对称二叉树，简单

核心方法：递归。注意三个终止条件

+ 时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。

+ 空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root: return True
        def next(l, r):
            # 结束条件
            if not l and not r:
                # 左右节点都为空
                return True
            if not l or not r:
                # 左右节点有一个为空
                return False
            if l.val != r.val:
                # 左右节点值不想等
                return False
            return next(l.left, r.right) and next(l.right, r.left)
        return next(root.left, root.right)
```

核心方法：迭代，使用队列。如果当前节点满足条件，就将下面待比较的每组添加到队列中，直到队列为空

+ 时间复杂度：O(n)

+ 空间复杂度：O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        # 使用队列
        if not root: return True
        q = [(root.left, root.right)]
        
        while q:
            left, right = q.pop()
            if not left and not right:
                continue
            
            if left and right and left.val == right.val:
                q.append((left.left, right.right))
                q.append((left.right, right.left))
            else:
                return False
        return True
```



98，验证二叉搜索树，中等

核心方法：递归，在向下探索的过程中，不断检查左子节点，右子节点和根结点的关系是否满足条件；只要不满足条件，直接return False

时间复杂度：O(n)

空间复杂度：O(n)，树高最高为n

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        if not root: 
            return True

        def search(node, min_v, max_v):
            if not node: 
                return True

            if node.left:
                if node.left.val >= node.val or node.left.val <= min_v:
                    return False

            if node.right:
                if node.right.val <= node.val or node.right.val >= max_v:
                    return False

            return search(node.left, min_v, node.val) and search(node.right, node.val, max_v)
        
        return search(root, -2**32, 2**32)
```

根据搜索二叉树的性质，中序遍历得到的结果一定是升序的。那么通过迭代的方法，中序遍历这个树，分别记录每个节点的值，然后判断当前遍历到的值是否大于上一个值，如果不大于，则return False，全遍历完后return True。使用栈来维护每个根结点。

```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack, inorder = list(), float('-inf')
        
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            if root.val <= inorder:
                return False
            inorder = root.val
            root = root.right
            
        return True
```

